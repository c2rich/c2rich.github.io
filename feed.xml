<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="zh-CN"><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" hreflang="zh-CN" /><updated>2022-05-01T18:14:35+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">奇幻之旅</title><subtitle>开始奇幻编程之旅
</subtitle><author><name>qihuan</name></author><entry><title type="html">数据库</title><link href="http://localhost:4000/2022/05/01/%E6%95%B0%E6%8D%AE%E5%BA%93.html" rel="alternate" type="text/html" title="数据库" /><published>2022-05-01T00:00:00+08:00</published><updated>2022-05-01T00:00:00+08:00</updated><id>http://localhost:4000/2022/05/01/%E6%95%B0%E6%8D%AE%E5%BA%93</id><content type="html" xml:base="http://localhost:4000/2022/05/01/%E6%95%B0%E6%8D%AE%E5%BA%93.html"><![CDATA[<h1 id="1数据库的相关概念">1，数据库的相关概念</h1>

<h2 id="11--数据">1.1  <strong>数据</strong></h2>

<p>1，定义：描述事务的符号</p>

<p>2，表达形式：多种表现形式：文本，<strong>图形，音频，视频</strong></p>

<h2 id="12--数据库database-db">1.2  <strong>数据库（Database, DB）</strong></h2>

<p>1，粮库  车库</p>

<p>2，存放数据的仓库 存放在计算机中，按照一定格式存放  可为用户共享</p>

<h2 id="13-数据库管理系统database-management-system-dbms">1.3 <strong>数据库管理系统（Database Management System, DBMS）</strong></h2>

<p>1，如何科学的组织和存储数据，如何高效的获取和维护数据，靠数据库管理系统完成</p>

<p>2，Oracle  MySQL SQL Server  DB2 FoxPro，Access  sqlite</p>

<h2 id="14-数据库应用程序dbas">1.4 <strong>数据库应用程序（DBAS）</strong></h2>

<p>1，在数据库管理系统基础上，使用数据库管理系统的语法，开发的直接面对<strong>最终用户</strong>的应用程序</p>

<p>2，学生管理系统、人事管理系统、图书管理系统</p>

<h2 id="15-数据库管理员database-administrator-dba">1.5 <strong>数据库管理员（Database Administrator, DBA）</strong></h2>

<p>1，数据库管理系统的操作者</p>

<h2 id="16-最终用户">1.6 <strong>最终用户</strong></h2>

<p>1，数据库应用程序的使用者</p>

<h2 id="17-数据库系统">1.7 <strong>数据库系统</strong></h2>

<p>1，数据库+数据库管理系统+数据库应用程序+最终用户</p>

<p>![img](数据库/wpsD145.tmp.png”/&gt;</p>

<h2 id="18-数据库的发展阶段">1.8 <strong>数据库的发展阶段</strong></h2>

<p>1，网状数据库</p>

<p>2，层次数据库【tree】</p>

<p>3，关系数据库</p>

<p>采用关系[二维表]结构存储与管理数据</p>

<p>采用结构化查询语言(sql)作为客户端数据库服务器间沟通的桥梁</p>

<p>目前主流的数据库技术</p>

<p><img src="/数据库/wpsB88F.tmp.jpg" /></p>

<p>4，对象数据库</p>

<h2 id="19-nosql数据库">1.9 <strong>NOSQL数据库</strong></h2>

<p>1，Not only sql数据库 泛指非关系数据库。如MongoDB,Redis</p>

<p>2，关系数据库在超大规模和高并发的web2.0纯属动态网站已经显示力不从心，暴露了很多难以克服的问题。Nosql数据库的产生就是为了解决大无框数据集合多重数据种类带来的挑战，尤其是大数据应用难题</p>

<h2 id="110-市场上流行的关系型数据库">1.10 <strong>市场上流行的关系型数据库</strong></h2>

<table>
  <thead>
    <tr>
      <th>数据库</th>
      <th>厂商</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Oracle</td>
      <td>甲骨文公司</td>
    </tr>
    <tr>
      <td>MySQL</td>
      <td>MySQL甲骨文</td>
    </tr>
    <tr>
      <td>SQLServer</td>
      <td>Microsoft</td>
    </tr>
    <tr>
      <td>DB2</td>
      <td>IBM</td>
    </tr>
    <tr>
      <td>Sqlite</td>
      <td>RichardHipp</td>
    </tr>
  </tbody>
</table>

<h1 id="2-数据库的相关操作">2 ，数据库的相关操作</h1>

<h2 id="21-启动停止">2.1 <strong>启动|停止</strong></h2>

<h3 id="方式1">【方式1】</h3>

<table>
  <tbody>
    <tr>
      <td>cmd– net start</td>
      <td>stop mysql</td>
    </tr>
  </tbody>
</table>

<p><img src="/数据库/1637283771326.png" /></p>

<p>以上的错的原因是因为没有管理员权限</p>

<p><img src="/数据库/1637283832813.png" /></p>

<p><img src="/数据库/1637283931230.png" /></p>

<h3 id="方式2">【方式2】</h3>

<p>win+R   – control–打开控制面板</p>

<p><img src="/数据库/1637283978552.png" /></p>

<p><img src="/数据库/1637283989190.png" /><img src="/数据库/1637284016441.png" /></p>

<p><img src="/数据库/1637284100787.png" /></p>

<h2 id="22-使用root账户登陆">2.2 <strong>使用root账户登陆</strong></h2>

<p>mysql -uroot -p123456</p>

<p>root是默认的用户名—超级管理员</p>

<p>123456是之前我们安装的时候设置的默认密码</p>

<h2 id="23-显示所有数据库">2.3 <strong>显示所有数据库</strong></h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>show databases;
</code></pre></div></div>

<p><img src="/数据库/1637284204500.png" /></p>

<h2 id="24-默认的几个数据库说明">2.4 默认的几个数据库说明</h2>

<h3 id="241-information_schema">2.4.1 <strong>information_schema</strong></h3>

<p>information_schema数据库是MySQL自带的，它提供了访问数据库元数据的方式。什么是元数据呢？元数据是关于数据的数据，如数据库名或表名，列的数据类型，或访问权限等。有些时候用于表述该信息的其他术语包括“数据词典”和“系统目录”。</p>

<p>在MySQL中，把 information_schema 看作是一个数据库，确切说是信息数据库。其中保存着关于MySQL服务器所维护的所有其他数据库的信息。如数据库名，数据库的表，表栏的数据类型与访问权 限等。在INFORMATION_SCHEMA中，有数个只读表。它们实际上是视图，而不是基本表，因此，你将无法看到与之相关的任何文件</p>

<h3 id="242-mysql">2.4.2 <strong>mysql</strong></h3>

<p>这个是mysql的核心数据库，主要负责存储数据库的用户、权限设置、关键字等mysql自己需要使用的控制和管理信息。不可以删除，如果对mysql不是很了解，也不要轻易修改这个数据库里面的表信息。</p>

<p><img src="/数据库/1637284578700.png" /></p>

<h3 id="243-performance_schema">2.4.3 <strong>performance_schema</strong></h3>

<p>mysql 5.5 版本 新增了一个性能优化的引擎： PERFORMANCE_SCHEMA这个功能默认是关闭的：</p>

<p>需要设置参数： performance_schema  才可以启动该功能，这个参数是静态参数，只能写在</p>

<p>my.cnf 中 不能动态修改。</p>

<p>windows里面叫 my.ini文件    C:\ProgramData\MySQL\MySQL Server 5.7   【默认在这个目录】</p>

<p>linux里面叫my.cnf文件</p>

<h3 id="244-sys">2.4.4 <strong>sys</strong></h3>

<p>通过这个库可以快速的了解系统的元数据信息</p>

<p>这个库确实可以方便DBA发现数据库的很多信息，解决性能瓶颈都提供了巨大帮助</p>

<h3 id="245-重要说明">2.4.5 <strong>重要说明</strong></h3>

<p>以上的4个默认库。都不要删除，只有自己创建的库可以删除</p>

<h2 id="25-使用某一个数据库">2.5 <strong>使用某一个数据库</strong></h2>

<p><img src="/数据库/1637284769121.png" /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>-- 语法
-- use  &lt;数据库名称&gt;;
-- 例如：使用mysql数据库
use mysql;
</code></pre></div></div>

<h2 id="26-修改密码">2.6 <strong>修改密码</strong></h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>-- 1使用mysql数据库
use mysql;
-- 2修改密码命令(将root用户的密码修改为123456)
update mysql.user set authentication_string=PASSWORD('123456') where user='root;
-- 3刷新
flush privileges;
</code></pre></div></div>

<h2 id="27-创建用户">2.7 <strong>创建用户</strong></h2>

<h3 id="271-命令">2.7.1 <strong>命令</strong></h3>

<pre><code class="language-mysql">CREATE USER 'username'@'host' IDENTIFIED BY 'password';
</code></pre>

<h3 id="272-说明">2.7.2 <strong>说明</strong></h3>

<pre><code class="language-mysql">username：你将创建的用户名
host：指定该用户在哪个主机上可以登陆，如果是本地用户可用localhost，如果想让该用户可以从任意远程主机登陆，可以使用通配符%
password：该用户的登陆密码，密码可以为空，如果为空则该用户可以不需要密码登陆服务器
</code></pre>

<h3 id="273-例子">2.7.3 <strong>例子</strong></h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>CREATE USER 'dog'@'localhost' IDENTIFIED BY '123456';
CREATE USER 'pig'@'192.168.1.101' IDENDIFIED BY '123456';
CREATE USER 'pig'@'%' IDENTIFIED BY '123456';
CREATE USER 'pig'@'%' IDENTIFIED BY '';
CREATE USER 'pig'@'%';
</code></pre></div></div>

<h2 id="28-给用户授权">2.8 <strong>给用户授权</strong></h2>

<h3 id="281-命令">2.8.1 <strong>命令</strong></h3>

<pre><code class="language-mysql">GRANT privileges ON databasename.tablename TO 'username'@'host'
</code></pre>

<h3 id="282-说明">2.8.2 <strong>说明</strong></h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>privileges：用户的操作权限，如SELECT，INSERT，UPDATE等，如果要授予所的权限则使用ALL
databasename：数据库名
tablename：表名，如果要授予该用户对所有数据库和表的相应操作权限则可用*表示，如*.*
</code></pre></div></div>

<h3 id="283-例子">2.8.3 <strong>例子</strong></h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>GRANT SELECT ON wh2105.user TO 'dog'@'localhost';
		|--给host=localhost这个用户对wh2105数据库的user表的查询权限
GRANT ALL ON *.* TO 'dog'@'%';
		|--给host=%的dog用户  对所有数据库的所有表表的所有权限
GRANT ALL ON wh2105.* TO 'dog'@'%';
		|--给host=%的dog用户  对wh2105数据库的所有表的所有权限
</code></pre></div></div>

<h3 id="284-注意">2.8.4 <strong>注意</strong></h3>

<p>用以上命令授权的用户不能给其它用户授权，如果想让该用户可以授权，用以下命令:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>GRANT privileges ON databasename.tablename TO 'username'@'host' WITH GRANT OPTION;
</code></pre></div></div>

<h3 id="285-作用">2.8.5 <strong>作用</strong></h3>

<p>多公司协同开发的，如A公司需要B公司的数据，那么A公司可以创建一个用户给B公司，并且去设置相关权限</p>

<h2 id="29-创建一个数据库">2.9 <strong>创建一个数据库</strong></h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>-- 创建数据库有两种方式：
-- 第一种 语法如下
-- 注意：&lt;&gt;里面的内容都是可变的
-- create database &lt;数据库名称&gt;;
-- 例如
create database whqihuan;
-- 第二种 语法如下
-- if not exists 创建之前会做check操作，如果数据库名称在MySQL数据库管理系统中不存在才创建
-- charset default 为数据库指定默认编码
-- create database if not exists &lt;数据库名称&gt;  default charset  &lt;数据库字符集编码&gt;;
-- 例如：
create database if not exists whqihuan default charset UTF8;
create database if not exists whqihuan default charset UTF8MB4;
-- UTF8和UTF8MB4区别？
-- 绝大多数情况下使用UTF8编码的字符集一个汉字占据3个字符，但是有极少数情况下一个汉字占据4个字符
-- 占据4个字符的汉字不能使用UTF8存储，必须使用UTF8MB4存储
-- UTF8MB4字符集编码表示一个汉字最多占据4个字符  M Most  B Byte  可以存放微信的表情
-- 注意：创建数据库指定的字符集编码必须跟MySQL数据库里面的my.ini字符集编码保持一致
</code></pre></div></div>

<h2 id="210-删除一个数据库">2.10 <strong>删除一个数据库</strong></h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>-- 第一种方式 语法：
-- drop database &lt;数据库名称&gt;;
-- 例如：
drop database whqihuan;
-- 第二种方式 语法：
-- 删除之前先判断 存在才删除
-- drop database if exists &lt;数据库名称&gt;;
-- 例如：
drop database if exists whqihuan;
</code></pre></div></div>

<h2 id="211-修改数据库默认编码">2.11 修改数据库默认编码</h2>

<p><img src="/数据库/1637286573409.png" /></p>

<p>C:\ProgramData\MySQL\MySQL Server 5.7</p>

<p><img src="/数据库/1637286592935.png" /></p>

<p><img src="/数据库/1637286653497.png" /></p>

<p><img src="/数据库/1637286676484.png" /></p>

<p>重启mysql</p>

<h1 id="3-什么是sql">3. <strong>什么是SQL</strong></h1>

<p>SQL是一个面向过程的结构化查询语言，全称Struct Query Language 。我们对MySQL做的任何操作(命令)都建立在结构化查询语言中。</p>

<p>SQL由以下四部分组成：DDL、DML、DQL、TCL ,DCL</p>

<h2 id="31ddl-数据定义语言">3.1DDL 数据定义语言</h2>

<p>全称Data Definition Language，主要用于创建和删除结构。</p>

<p>Ø 1)创建结构相关操作：表、视图、索引、数据</p>

<p>Ø 2)删除结构相关操作：表、视图、索引、数据</p>

<p>Ø 3)改变结构相关操作：表、视图、索引、数据</p>

<h2 id="32-dml-数据操纵语言">3.2 DML 数据操纵语言</h2>

<p>DML对表和视图进行插入、删除、更新相关操作，全称Data Manipulation Language。</p>

<p>插入数据关键字：insert</p>

<p>删除数据关键字：delete</p>

<p>修改数据关键字：update</p>

<h2 id="33-dql-数据查询语言">3.3 <strong>DQL 数据查询语言</strong></h2>

<p>对表和视图进行操作，全称： Data Query Language</p>

<h2 id="34-dql关键字-select">3.4 DQL关键字 select</h2>

<p>TCL全称Transaction Control Language，使用事务管理DML操作。</p>

<p>Ø  提交事务关键字 commit;</p>

<p>Ø  回滚事务关键字 rollback;</p>

<p>Ø  开启事务关键字 start transaction;</p>

<h2 id="35-dcl-数据控制语言">3.5 DCL 数据控制语言</h2>

<p>Data Control Language
主控制权限</p>

<h1 id="4-mysql数据类型">4. <strong>MySQL数据类型</strong></h1>

<h2 id="41-整数类型javainteger-long">4.1 <strong>整数类型</strong>—java[Integer Long]</h2>

<table>
  <thead>
    <tr>
      <th><strong>数据类型</strong></th>
      <th><strong>大小</strong></th>
      <th><strong>描述</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>tinyint</td>
      <td>8bit</td>
      <td>范围(-128~127)</td>
    </tr>
    <tr>
      <td>smallint</td>
      <td>16bit</td>
      <td>范围(-32768~32767)</td>
    </tr>
    <tr>
      <td>mediumint</td>
      <td>24bit</td>
      <td>范围(-8388608~8388607)</td>
    </tr>
    <tr>
      <td><strong>int</strong></td>
      <td><strong>32bit</strong></td>
      <td><strong>范围(-2147483648~2147483647)</strong></td>
    </tr>
    <tr>
      <td><strong>bigint</strong></td>
      <td><strong>64bit</strong></td>
      <td><strong>范围(+-9.22*10的18次方)</strong></td>
    </tr>
  </tbody>
</table>

<h2 id="42-小数类型javafloat--double">4.2 <strong>小数类型</strong>—java[float  double]</h2>

<table>
  <thead>
    <tr>
      <th>float(m,d)</th>
      <th>32bit</th>
      <th>单精度浮点型，m总个数，d小数位</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>double(m,d)</td>
      <td>64bit</td>
      <td>双精度浮点型，m总个数，d小数位</td>
    </tr>
  </tbody>
</table>

<h2 id="43-定点数-javabigdecimal">4.3 <strong>定点数</strong>—-java[BigDecimal]</h2>

<p>浮点型在数据库中存放的是近似值，而定点类型在数据库中存放的是精确值。 decimal(m,d) 参数m是总个数，d是小数位。</p>

<h2 id="44-字符串-javastring">4.4 <strong>字符串</strong> —java[String]</h2>

<table>
  <thead>
    <tr>
      <th><strong>MySQL数据类型</strong></th>
      <th><strong>含义</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>char(n)</strong></td>
      <td>固定长度，最多255个字符，<strong>索引效率级高</strong>，必须在括号里定义长度，可以有默认值</td>
    </tr>
    <tr>
      <td><strong>varchar(n)</strong></td>
      <td><strong>可变长度，最多65535个字符</strong></td>
    </tr>
    <tr>
      <td>tinytext</td>
      <td>可变长度，最多255个字符</td>
    </tr>
    <tr>
      <td><strong>text</strong></td>
      <td><strong>可变长度，最多65535个字符</strong></td>
    </tr>
    <tr>
      <td>mediumtext</td>
      <td>可变长度，最多2的24次方-1个字符</td>
    </tr>
    <tr>
      <td>longtext</td>
      <td>可变长度，最多2的32次方-1个字符</td>
    </tr>
    <tr>
      <td><strong>json</strong></td>
      <td><strong>mysql5.7新增加的数据类型，用来存放json数据</strong></td>
    </tr>
  </tbody>
</table>

<p><strong>char：</strong>存储定长数据很方便，CHAR字段上的索引效率级高，必须在括号里定义长度，可以有默认值，比如定义char(10)，那么不<strong>论你存储的数据是否达到了10个字节，都要占去10个字节的空间</strong>（自动用空格填充），且在检索的时候后面的空格会隐藏掉，所以检索出来的数据需要记得用什么trim之类的函数去过滤空格。</p>

<p><strong>varchar</strong>：存储变长数据，但存储效率没有CHAR高，必须在括号里定义长度，可以有默认值。<strong>保存数据的时候，不进行空格自动填充，而且如果数据存在空格时，当值保存和检索时尾部的空格仍会保留。</strong>另外，varchar类型的实际长度是它的值的实际长度+1，这一个字节用于保存实际使用了多大的长度。</p>

<p><strong>text：</strong>存储可变长度的非Unicode数据，最大长度为2^31-1个字符。text列不能有默认值，存储或检索过程中，不存在大小写转换，后面如果指定长度，不会报错误，但是这个长度是不起作用的，意思就是你插入数据的时候，超过你指定的长度还是可以正常插入。text默认不走索引</p>

<p>1、经常变化的字段用varchar；</p>

<p>2、知道固定长度的用char；</p>

<p>3、超过255字节的只能用varchar或者text；</p>

<p>4、能用varchar的地方不用text；</p>

<p>5、能够用数字类型的字段尽量选择数字类型而不用字符串类型，这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连接回逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了；</p>

<p>6、同一张表出现多个大字段，能合并时尽量合并，不能合并时考虑分表</p>

<h2 id="45-日期时间类型java-date-localdate-timestemp">4.5 <strong>日期时间类型</strong>[java Date LocalDate Timestemp]</h2>

<table>
  <thead>
    <tr>
      <th>date</th>
      <th>日期 ‘2021-1-1’</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>time</td>
      <td>时间 ‘12:25:36’</td>
    </tr>
    <tr>
      <td>datetime</td>
      <td>日期时间 ‘2021-1-1 22:06:44’</td>
    </tr>
    <tr>
      <td>timestamp</td>
      <td>自动存储记录修改时间[如果修改表的数据，这个字段自动更新]</td>
    </tr>
  </tbody>
</table>

<h2 id="46-logic类型了解">4.6 Logic类型【了解】</h2>

<p>Logic类型使用bit表示，它只能存储两个值0或者1</p>

<h2 id="47-数据类型的属性">4.7 <strong>数据类型的属性</strong></h2>

<table>
  <thead>
    <tr>
      <th>MySQL关键字</th>
      <th>含义</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>NULL</td>
      <td>数据列可包含NULL值</td>
    </tr>
    <tr>
      <td>NOT NULL</td>
      <td>数据列不允许包含NULL值</td>
    </tr>
    <tr>
      <td>DEFAULT</td>
      <td>默认值</td>
    </tr>
    <tr>
      <td>PRIMARY KEY</td>
      <td>主键</td>
    </tr>
    <tr>
      <td>AUTO_INCREMENT</td>
      <td>自动递增，适用于整数类型</td>
    </tr>
    <tr>
      <td>CHARACTER SET name</td>
      <td>指定一个字符集</td>
    </tr>
  </tbody>
</table>

<h1 id="5mysql表的相关操作ddl">5.MySQL表的相关操作DDL</h1>

<h2 id="51-创建表">5.1 <strong>创建表</strong></h2>

<h3 id="511-语法">5.1.1 语法</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>create table &lt;表名&gt;(
   字段名  数据类型  属性,
   字段名  数据类型  属性,
   字段名  数据类型  属性,
   字段名  数据类型  属性
)
</code></pre></div></div>

<h3 id="512实例创建一个学生表tb_student">5.1.2，实例创建一个学生表tb_student</h3>

<p><img src="/数据库/1637290484249.png" /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>CREATE TABLE tb_student(
	 id int COMMENT '学生编号',
	 stu_name varchar(20) COMMENT '学生姓名',
	 stu_age int COMMENT '学生年龄',
	 stu_sex char(1) COMMENT '学生性别',
	 stu_hobby varchar(255) COMMENT '学生爱好'
);
</code></pre></div></div>

<p><img src="/数据库/1637290652759.png" /></p>

<h3 id="513创建一个学生表tb_student并指定编码和存储引擎">5.1.3,创建一个学生表tb_student并指定编码和存储引擎</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>CREATE TABLE tb_student(
	 id int COMMENT '学生编号',
	 stu_name varchar(20) COMMENT '学生姓名',
	 stu_age int COMMENT '学生年龄',
	 stu_sex char(1) COMMENT '学生性别',
	 stu_hobby varchar(255) COMMENT '学生爱好'
) DEFAULT CHARSET=UTF8MB4,ENGINE INNODB;
</code></pre></div></div>

<h2 id="52-数据存储的问题">5.2 <strong>数据存储的问题</strong></h2>

<p>以上的表创建成功之后，如果电脑关掉，那么内存的数据会清空，但是我们发现表还存在，那么说表的结构是存储在硬盘里面的，【那么存的哪的呢】</p>

<p>现在我们在数据库中创建了一个表，那么如我们把电脑重启，这个表还在不在呢？</p>

<p>测试结果为   在   那是为什么呢？</p>

<p>原因是当我们创建表个表之后，在我们数据库的文件系统里面就会有一个对应的文件存在</p>

<p><img src="/数据库/wpsDB08.tmp.jpg" /></p>

<p><strong>.frm文件：保存了每个表的元数据，包括表结构的定义等；</strong></p>

<p><strong>.ibd文件：InnoDB引擎开启了独立表空间(my.ini中配置innodb_file_per_table = 1)产生的存放该表的数据和索引的文件。</strong></p>

<h2 id="53-查看表结构">5.3 <strong>查看表结构</strong></h2>

<p>创建表之后如何查看是否创建成功？可以通过desc命令来查看表结构</p>

<pre><code class="language-mysql">-- 第一种方式查看表结构
-- desc &lt;表名称&gt;;
desc student;
-- 第二种方式查看表结构
-- show create table &lt;表名称&gt;;
show create table tb_student;
</code></pre>

<p><img src="/数据库/1637291175934.png" /></p>

<p><img src="/数据库/1637291214301.png" /></p>

<h2 id="54-修改表结构">5.4 <strong>修改表结构</strong></h2>

<p>基本语法如下：alter table <表名称>;</表名称></p>

<h3 id="541向student表新增加一列stu_height学生身高">5.4.1,向student表新增加一列stu_height学生身高</h3>

<p>[语法]</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>-- 语法如下：
-- alter table &lt;表名称&gt; add column &lt;列名称&gt;  &lt;数据类型&gt;;
alter table student add column stu_height int(11);
-- 查看表结构
desc student;
</code></pre></div></div>

<h3 id="541删除student表中的学生身高">5.4.1,删除student表中的学生身高</h3>

<p>[语法]</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>-- 语法如下：
-- alter table &lt;表名称&gt; drop column &lt;列名称&gt;;
alter table student drop column stu_height;
</code></pre></div></div>

<h3 id="541例如修改stu_sex-为-student_sex-数据类型修改为-varchar30"><strong>5.4.1,例如修改stu_sex 为 student_sex 数据类型修改为 varchar(30)</strong></h3>

<p>【语法】</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- 语法如下：</span>
<span class="c1">-- alter table &lt;表名称&gt; change column &lt;原列名称&gt; &lt;新列名称&gt; &lt;数据类型&gt;;</span>
<span class="c1">-- 修改stu_sex 为 student_sex 数据类型修改为 varchar(30)</span>
<span class="k">alter</span> <span class="k">table</span> <span class="n">student</span> <span class="n">change</span> <span class="k">column</span> <span class="n">stu_sex</span> <span class="n">student_sex</span> <span class="nb">varchar</span><span class="p">(</span><span class="mi">30</span><span class="p">);</span>
</code></pre></div></div>

<h3 id="541将学生性别修改为int类型">5.4.1,将学生性别修改为int类型</h3>

<p>【语法】</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- 语法如下：</span>
<span class="c1">-- alter table  &lt;表名称&gt; modify column &lt;原来的列名称&gt;  &lt;新的数据类型&gt;;</span>
<span class="c1">-- 例如：</span>
<span class="k">alter</span> <span class="k">table</span> <span class="n">student</span> <span class="k">modify</span> <span class="k">column</span> <span class="n">student_age</span> <span class="nb">int</span><span class="p">(</span><span class="mi">11</span><span class="p">);</span>
</code></pre></div></div>

<h2 id="55-删除表">5.5 <strong>删除表</strong></h2>

<h3 id="111-直接删除">1.1.1 <strong>直接删除</strong></h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>-- drop table &lt;表名称&gt;;
drop table EMP_bak;
</code></pre></div></div>

<h3 id="112-删除之前先判断表是否存在">1.1.2 <strong>删除之前先判断表是否存在</strong></h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>-- drop table if exists &lt;表名称&gt;;
-- 刪除之前先做校验，表在数据库中存在才删除
drop table if exists EMP_bak;
</code></pre></div></div>

<h2 id="56-显示当前库的所有表">5.6 <strong>显示当前库的所有表</strong></h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>show tables;
</code></pre></div></div>

<h1 id="6mysql表里面数据的相关操作dml">6，MySQL表里面数据的相关操作DML</h1>

<p><img src="/数据库/1637302180718.png" /></p>

<h2 id="61添加数据">6.1，添加数据</h2>

<h3 id="611一条一条的添加">6.1.1，一条一条的添加</h3>

<p>【语法】</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>insert into &lt;表名&gt;(字段名1，字段名2，字段名N) values(值1，值2，值N);
insert into &lt;表名&gt; values(表里面已存在的所有字段的值)
</code></pre></div></div>

<p>【实例】</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>insert into tb_student(id,stu_name,stu_age,stu_sex,stu_hobby) values(1,'小明',22,1,"DOTA");
</code></pre></div></div>

<h3 id="612一组一组的加">6.1.2，一组一组的加</h3>

<p>【语法】</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>insert into tb_student(id,stu_name,stu_age,stu_sex,stu_hobby)
		values(3,'小丽',22,1,"DOTA"),(3,'小芳',22,1,"DOTA");
</code></pre></div></div>

<h2 id="62修改数据">6.2，修改数据</h2>

<h3 id="621一条一条的修改">6.2.1，一条一条的修改</h3>

<p>【语法】</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>update &lt;表名&gt; set 字段名=修改后的值,字段名=修改后的值……………… where id=1;
</code></pre></div></div>

<p>【实例】 把id=1的学生名字变成张大明</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>update tb_student set stu_name='张大名' where id=1;
</code></pre></div></div>

<h3 id="622一组一组的修改">6.2.2，一组一组的修改</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>		-- 把表里面所有的名字变成张大名
		update tb_student set stu_name='张大名'
		-- 把年龄大于20的学生爱好变成 LOL
		update tb_student set stu_hobby='LOL' where stu_age&gt;20
</code></pre></div></div>

<h2 id="63删除数据">6.3，删除数据</h2>

<h3 id="631一条一条的修改">6.3.1，一条一条的修改</h3>

<p>【语法】</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>delete from &lt;表名&gt;  where 条件
</code></pre></div></div>

<p>【实例】删除ID=1的学生</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>delete from tb_student where id=1;
</code></pre></div></div>

<h3 id="632一组一组的修改">6.3.2，一组一组的修改</h3>

<p>【实例】 删除所有学生信息</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>delete from tb_student;
</code></pre></div></div>

<p>【实例】 删除 年龄大于20的学生</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>delete from tb_student where stu_age&gt;20;
</code></pre></div></div>

<h2 id="633truncate关键字">6.3.3，truncate关键字</h2>

<p>原理：删表再重建</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>truncate是DDL，删除所有数据，不支持where，不能回滚
delete是DML，可以删除部分数据，因为支持where，可以回滚
总体上truncate效率比delete高，他们都只能删除数据不能删除表结构，只有drop才能删除表结构
</code></pre></div></div>

<h1 id="7-数据完整性">7. <strong>数据完整性</strong></h1>

<p>为什么要学习数据完整性？我们上面创建的tb_student表缺乏安全性，还会有重复的id，这些都是脏数据。</p>

<p>什么是数据完整性？需要为MySQL数据库中的表定义一个规则，确保表中数据的有效性、一致性、安全性、尽最大的可能减少脏数据，重复的数据(冗余)。、</p>

<h2 id="71-主键约束">7.1 <strong>主键约束</strong></h2>

<p>特点：非空并且唯一</p>

<h3 id="添加方法创建表时添加">添加方法[创建表时添加]</h3>

<p>```sql lite
CREATE TABLE tb_student(
	 id int  primary key  COMMENT ‘学生编号’,
	 stu_name varchar(20) COMMENT ‘学生姓名’,
	 stu_age int COMMENT ‘学生年龄’,
	 stu_sex char(1) COMMENT ‘学生性别’,
	 stu_hobby varchar(255) COMMENT ‘学生爱好’
);</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
```sql
CREATE TABLE tb_student(
	 id int   COMMENT '学生编号',
	 stu_name varchar(20) COMMENT '学生姓名',
	 stu_age int COMMENT '学生年龄',
	 stu_sex char(1) COMMENT '学生性别',
	 stu_hobby varchar(255) COMMENT '学生爱好',
	 primary key (id)
);
</code></pre></div></div>

<h3 id="主键的自动增长">主键的自动增长</h3>

<p>【添加数据的时不用给主键设置值，会根据数据库里面的数据进行自动递增】</p>

<p>【设置方式】</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">tb_student</span><span class="p">(</span>
	 <span class="n">id</span> <span class="nb">int</span>  <span class="n">auto_increment</span>  <span class="k">COMMENT</span> <span class="s1">'学生编号'</span><span class="p">,</span>
	 <span class="n">stu_name</span> <span class="nb">varchar</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span> <span class="k">COMMENT</span> <span class="s1">'学生姓名'</span><span class="p">,</span>
	 <span class="n">stu_age</span> <span class="nb">int</span> <span class="k">COMMENT</span> <span class="s1">'学生年龄'</span><span class="p">,</span>
	 <span class="n">stu_sex</span> <span class="nb">char</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="k">COMMENT</span> <span class="s1">'学生性别'</span><span class="p">,</span>
	 <span class="n">stu_hobby</span> <span class="nb">varchar</span><span class="p">(</span><span class="mi">255</span><span class="p">)</span> <span class="k">COMMENT</span> <span class="s1">'学生爱好'</span><span class="p">,</span>
	 <span class="k">primary</span> <span class="k">key</span> <span class="p">(</span><span class="n">id</span><span class="p">)</span>
<span class="p">);</span>
</code></pre></div></div>

<p><img src="/数据库/1637305715514.png" /></p>

<h2 id="72-非空约束">7.2 非空<strong>约束</strong></h2>

<p>特点：不能为空</p>

<p>语法 属性名  类型  not null</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">tb_student</span><span class="p">(</span>
	 <span class="n">id</span> <span class="nb">int</span>  <span class="n">auto_increment</span>  <span class="k">COMMENT</span> <span class="s1">'学生编号'</span><span class="p">,</span>
	 <span class="n">stu_name</span> <span class="nb">varchar</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span> <span class="k">not</span> <span class="k">null</span> <span class="k">COMMENT</span>  <span class="s1">'学生姓名'</span><span class="p">,</span>
	 <span class="n">stu_age</span> <span class="nb">int</span> <span class="k">COMMENT</span> <span class="s1">'学生年龄'</span><span class="p">,</span>
	 <span class="n">stu_sex</span> <span class="nb">char</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="k">COMMENT</span> <span class="s1">'学生性别'</span><span class="p">,</span>
	 <span class="n">stu_hobby</span> <span class="nb">varchar</span><span class="p">(</span><span class="mi">255</span><span class="p">)</span> <span class="k">COMMENT</span> <span class="s1">'学生爱好'</span><span class="p">,</span>
	 <span class="k">primary</span> <span class="k">key</span> <span class="p">(</span><span class="n">id</span><span class="p">)</span>
<span class="p">);</span>
</code></pre></div></div>

<h2 id="73-唯一约束">7.3 唯一<strong>约束</strong></h2>

<p>特点：不能重复</p>

<p>语法  属性名 类型  UNIQUE</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>CREATE TABLE tb_student(
	 id int  auto_increment  COMMENT '学生编号',
	 stu_name varchar(20) UNIQUE COMMENT  '学生姓名',
	 stu_age int COMMENT '学生年龄',
	 stu_sex char(1) COMMENT '学生性别',
	 stu_hobby varchar(255) COMMENT '学生爱好',
	 primary key (id)
);
</code></pre></div></div>

<h2 id="74-默认约束">7.4 默认<strong>约束</strong></h2>

<p>特点：当用户添加数据时，如果没有指定某一列的数据，那么就使用默认值</p>

<p>语法  字段名  类型   DEFAULT  默认值</p>

<p>【设置性别默认为‘1’】</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>CREATE TABLE tb_student(
	 id int  auto_increment  COMMENT '学生编号',
	 stu_name varchar(20) UNIQUE COMMENT  '学生姓名',
	 stu_age int COMMENT '学生年龄',
	 stu_sex char(1) DEFAULT '1' COMMENT '学生性别',
	 stu_hobby varchar(255) COMMENT '学生爱好',
	 primary key (id)
);
</code></pre></div></div>

<h2 id="75-外键约束">7.5 外键<strong>约束</strong></h2>

<p>以学生和班级为例</p>

<p>【创建班级表】</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">create</span> <span class="k">table</span> <span class="n">tb_cls</span><span class="p">(</span>
   <span class="n">clsId</span> <span class="nb">int</span> <span class="k">primary</span> <span class="k">key</span> <span class="n">auto_increment</span>  <span class="k">comment</span> <span class="s1">'班级编号'</span><span class="p">,</span>
   <span class="n">clsName</span> <span class="nb">varchar</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span> <span class="k">UNIQUE</span> <span class="k">comment</span> <span class="s1">'班级名称'</span><span class="p">,</span>
   <span class="n">clsRemark</span> <span class="nb">varchar</span><span class="p">(</span><span class="mi">50</span><span class="p">)</span> <span class="k">comment</span> <span class="s1">'班级备注'</span>
<span class="p">)</span>
    <span class="k">insert</span> <span class="k">into</span> <span class="n">tb_cls</span><span class="p">(</span><span class="n">clsId</span><span class="p">,</span><span class="n">clsName</span><span class="p">,</span><span class="n">clsRemark</span><span class="p">)</span> <span class="k">values</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nv">"JAVA一班"</span><span class="p">,</span><span class="nv">"JAVA一班"</span><span class="p">);</span>
    <span class="k">insert</span> <span class="k">INTO</span> <span class="n">tb_cls</span><span class="p">(</span><span class="n">clsId</span><span class="p">,</span><span class="n">clsName</span><span class="p">,</span><span class="n">clsRemark</span><span class="p">)</span> <span class="k">values</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="nv">"JAVA二班"</span><span class="p">,</span><span class="nv">"JAVA二班"</span><span class="p">);</span>
    <span class="k">insert</span> <span class="k">into</span> <span class="n">tb_cls</span><span class="p">(</span><span class="n">clsId</span><span class="p">,</span><span class="n">clsName</span><span class="p">,</span><span class="n">clsRemark</span><span class="p">)</span> <span class="k">values</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="nv">"JAVA三班"</span><span class="p">,</span><span class="nv">"JAVA三班"</span><span class="p">);</span>
</code></pre></div></div>

<p>【创建学生表】</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">create</span> <span class="k">table</span> <span class="n">tb_student</span><span class="p">(</span>
     <span class="n">stuId</span> <span class="nb">int</span>  <span class="k">primary</span> <span class="k">key</span> <span class="n">auto_increment</span>  <span class="k">COMMENT</span> <span class="s1">'学生编号'</span><span class="p">,</span>
	 <span class="n">stuName</span> <span class="nb">varchar</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span> <span class="k">UNIQUE</span> <span class="k">COMMENT</span>  <span class="s1">'学生姓名'</span><span class="p">,</span>
	 <span class="n">stuAge</span> <span class="nb">int</span> <span class="k">COMMENT</span> <span class="s1">'学生年龄'</span><span class="p">,</span>
	 <span class="n">stuSex</span> <span class="nb">char</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="k">DEFAULT</span> <span class="s1">'1'</span> <span class="k">COMMENT</span> <span class="s1">'学生性别'</span><span class="p">,</span>
	 <span class="n">stuHobby</span> <span class="nb">varchar</span><span class="p">(</span><span class="mi">255</span><span class="p">)</span> <span class="k">COMMENT</span> <span class="s1">'学生爱好'</span><span class="p">,</span>
     <span class="n">clsId</span> <span class="nb">int</span>  <span class="k">comment</span> <span class="s1">'班级编号'</span><span class="p">,</span>
      <span class="o">#</span><span class="err">添加外键</span>
	 <span class="k">FOREIGN</span> <span class="k">key</span><span class="p">(</span><span class="n">clsId</span><span class="p">)</span> <span class="k">REFERENCES</span> <span class="n">tb_cls</span><span class="p">(</span><span class="n">clsId</span><span class="p">)</span>
<span class="p">)</span>
<span class="k">insert</span> <span class="k">into</span> <span class="n">tb_student</span><span class="p">(</span><span class="n">stuName</span><span class="p">,</span><span class="n">stuAge</span><span class="p">,</span><span class="n">stuSex</span><span class="p">,</span><span class="n">stuHobby</span><span class="p">,</span><span class="n">clsId</span><span class="p">)</span> <span class="k">values</span><span class="p">(</span><span class="s1">'小明1'</span><span class="p">,</span><span class="mi">22</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="nv">"DOTA"</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
<span class="k">insert</span> <span class="k">into</span> <span class="n">tb_student</span><span class="p">(</span><span class="n">stuName</span><span class="p">,</span><span class="n">stuAge</span><span class="p">,</span><span class="n">stuSex</span><span class="p">,</span><span class="n">stuHobby</span><span class="p">,</span><span class="n">clsId</span><span class="p">)</span> <span class="k">values</span><span class="p">(</span><span class="s1">'小明2'</span><span class="p">,</span><span class="mi">22</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="nv">"DOTA"</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span>
<span class="k">insert</span> <span class="k">into</span> <span class="n">tb_student</span><span class="p">(</span><span class="n">stuName</span><span class="p">,</span><span class="n">stuAge</span><span class="p">,</span><span class="n">stuSex</span><span class="p">,</span><span class="n">stuHobby</span><span class="p">,</span><span class="n">clsId</span><span class="p">)</span> <span class="k">values</span><span class="p">(</span><span class="s1">'小明3'</span><span class="p">,</span><span class="mi">22</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="nv">"DOTA"</span><span class="p">,</span><span class="mi">3</span><span class="p">);</span>
<span class="k">insert</span> <span class="k">into</span> <span class="n">tb_student</span><span class="p">(</span><span class="n">stuName</span><span class="p">,</span><span class="n">stuAge</span><span class="p">,</span><span class="n">stuSex</span><span class="p">,</span><span class="n">stuHobby</span><span class="p">,</span><span class="n">clsId</span><span class="p">)</span> <span class="k">values</span><span class="p">(</span><span class="s1">'小明4'</span><span class="p">,</span><span class="mi">22</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="nv">"DOTA"</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
<span class="k">insert</span> <span class="k">into</span> <span class="n">tb_student</span><span class="p">(</span><span class="n">stuName</span><span class="p">,</span><span class="n">stuAge</span><span class="p">,</span><span class="n">stuSex</span><span class="p">,</span><span class="n">stuHobby</span><span class="p">,</span><span class="n">clsId</span><span class="p">)</span> <span class="k">values</span><span class="p">(</span><span class="s1">'小明5'</span><span class="p">,</span><span class="mi">22</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="nv">"DOTA"</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span>
<span class="k">insert</span> <span class="k">into</span> <span class="n">tb_student</span><span class="p">(</span><span class="n">stuName</span><span class="p">,</span><span class="n">stuAge</span><span class="p">,</span><span class="n">stuSex</span><span class="p">,</span><span class="n">stuHobby</span><span class="p">,</span><span class="n">clsId</span><span class="p">)</span> <span class="k">values</span><span class="p">(</span><span class="s1">'小明6'</span><span class="p">,</span><span class="mi">22</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="nv">"DOTA"</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
</code></pre></div></div>

<h4 id="1-外键定义的语法">1. 外键定义的语法</h4>

<p>通常在create table和alter table语句中定义外键约束，基本语法如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[CONSTRAINT [symbol]] FOREIGN KEY
    [index_name] (col_name, ...)
    REFERENCES tbl_name (col_name,...)
    [ON DELETE reference_option]
    [ON UPDATE reference_option]

reference_option:
    RESTRICT | CASCADE | SET NULL | NO ACTION | SET DEFAULT
</code></pre></div></div>

<p>CONSTRAINT symbol 为外键约束名称，如果没有定义，InnoDB表会自动生成一个名称，这个名称在数据库里面必须唯一。</p>

<p>ON DELETE、ON UPDATE表示事件触发时的动作，可设置值为：</p>

<ul>
  <li>CASCADE，更新或者删除父表记录时，子表中的相应记录同步更新或者删除。由级联更新或者删除导致的子表记录修改，不会触发子表的触发器执行。</li>
  <li>SET NULL，更新或者删除父表记录时，子表中的相应记录字段设置为NULL，前提是子表中相应字段不能定义为NOT NULL。</li>
  <li>RESTRICT，有外键关系约束时，拒绝父表记录的更新和删除操作。</li>
  <li>NO ACTION，无动作，实际功能与RESTRICT相同。</li>
  <li>SET DEFAULT，仅仅解析器能识别，实际功能未实现。</li>
</ul>

<h4 id="2-级联更新和级联删除">2. 级联更新和级联删除</h4>

<p>当父表对外键关联的字段进行update、delete操作时，子表对应的字段值也会同步变化，称之为级联更新或者级联删除。当外键定义时，设置 referential action 为CASCADE即可实现级联更新与删除。</p>

<p><strong>示例：</strong>
foreign key(parent_id) references parent(id) on update cascade</p>

<p>foreign key(parent_id) references parent(id) on delete cascade</p>

<p>foreign key(parent_id) references parent(id) on update cascade on delete cascade</p>

<h4 id="3-外键约束案例">3. 外键约束案例</h4>

<h5 id="31-外键约束字段值">3.1 外键约束字段值</h5>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># 创建父表
create table parent(id int, primary key(id));

# 创建子表
create table child(id int, parent_id int,
foreign key(parent_id) references parent(id),
primary key(id));
</code></pre></div></div>

<p>子表child会自动在parent_id字段上加上索引。往子表插入数据或者更新数据时，parent_id字段值必须为父表parent中已经存在的值，否则会报错。如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Cannot add or update a child row: a foreign key
constraint fails (`db`.`child`, CONSTRAINT `child_ibfk_1`
FOREIGN KEY (`parent_id`) REFERENCES `parent` (`id`))
</code></pre></div></div>

<p>删除父表中有外键约束的记录时，也会报错，如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> Cannot delete or update a parent row: a foreign key
constraint fails (`db`.`child`, CONSTRAINT `child_ibfk_1`
FOREIGN KEY (`parent_id`) REFERENCES `parent` (`id`))
</code></pre></div></div>

<h5 id="32-外键级联更新">3.2 外键级联更新</h5>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># 创建父表
create table parent(id int, primary key(id));

# 创建子表
create table child(id int, parent_id int,
foreign key(parent_id) references parent(id)
on update cascade,
primary key(id));
</code></pre></div></div>

<p>更新父表parent的id字段值，那么子表字段parent_id中相应的值也会同步更新。</p>

<h5 id="33-外键级联删除">3.3 外键级联删除</h5>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># 创建父表
create table parent(id int, primary key(id));

# 创建子表
create table child(id int, parent_id int,
foreign key(parent_id) references parent(id)
on delete cascade,
primary key(id));
</code></pre></div></div>

<p>删除父表parent的某个id字段值的记录，那么子表字段parent_id中相应值的记录也会同步删除。</p>

<h5 id="34-删除外键">3.4 删除外键</h5>

<pre><code class="language-mysql">alter table child drop foreign key child_ibfk_1;
</code></pre>

<h5 id="35-创建外键">3.5 创建外键</h5>

<pre><code class="language-mysql">alter table child add foreign key(parent_id) references parent(id);
</code></pre>

<h4 id="4-外键约束的条件和限制">4. 外键约束的条件和限制</h4>

<ol>
  <li>父表和子表必须为同一种存储引擎，且不能定义为临时表。</li>
  <li>创建外键约束需要有REFERENCES权限。</li>
  <li>外键约束中使用的字段必须有相似的数据类型，整型的大小必须相同，有无符号也必须相同。字符串类型的长度可以不相同，但是字符集和校验规则必须相同。</li>
  <li>外键约束的两个字段可以在同一个表中，但是不能是同一个字段。</li>
  <li>外键约束的字段上必须要有索引，以便加快外键检查，如果引用表上的外键字段没有索引的话，MySQL会自动创建一个索引。</li>
  <li>不支持外键字段上的前缀索引，blob和text字段不能用于外键。</li>
  <li>InnoDB表外键约束不支持分区。</li>
  <li>一个有外键约束的表不能修改其存储引擎。</li>
  <li>外键约束不能引用虚拟字段。</li>
</ol>

<p>总结</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>外键就是一个主从关系
学生和班
多个学生可以属性同一个班级
一个班级里面可以有多个学生
【学生角度关系】 多对一
【班级角度关系】 一对多

问题，如果班级的信息在学生表里面出现了，那么班级默认是不能删除的

</code></pre></div></div>

<h2 id="76-约束关键字总结">7.6 <strong>约束关键字总结</strong></h2>

<table>
  <thead>
    <tr>
      <th>约束名称</th>
      <th>关键字</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>主键约束</td>
      <td>primary key   自增   auto_increment</td>
    </tr>
    <tr>
      <td>非空约束</td>
      <td>not null</td>
    </tr>
    <tr>
      <td>唯一约束</td>
      <td>unique</td>
    </tr>
    <tr>
      <td>默认约束</td>
      <td>default</td>
    </tr>
    <tr>
      <td>外键约束</td>
      <td>foreign key()…….references 父表(父表的字段)</td>
    </tr>
  </tbody>
</table>

<h1 id="8-表关系">8. 表关系</h1>

<h2 id="81-一对一one-to-one了解">8.1 一对一（one-to-one）【了解】</h2>

<p>如果表里面的字段非常多，那么我们可以把表拆成1对1 的关系，但是如果不拆，放在一张里面也行，只是后期数据查询时可以能慢</p>

<h2 id="82-一对多多对一many-to-one掌握">8.2 一对多/多对一（many-to-one）【掌握】</h2>

<p>学生-班级</p>

<p>【创建班级表】</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">create</span> <span class="k">table</span> <span class="n">tb_cls</span><span class="p">(</span>
   <span class="n">clsId</span> <span class="nb">int</span> <span class="k">primary</span> <span class="k">key</span> <span class="n">auto_increment</span>  <span class="k">comment</span> <span class="s1">'班级编号'</span><span class="p">,</span>
   <span class="n">clsName</span> <span class="nb">varchar</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span> <span class="k">UNIQUE</span> <span class="k">comment</span> <span class="s1">'班级名称'</span><span class="p">,</span>
   <span class="n">clsRemark</span> <span class="nb">varchar</span><span class="p">(</span><span class="mi">50</span><span class="p">)</span> <span class="k">comment</span> <span class="s1">'班级备注'</span>
<span class="p">)</span>
    <span class="k">insert</span> <span class="k">into</span> <span class="n">tb_cls</span><span class="p">(</span><span class="n">clsId</span><span class="p">,</span><span class="n">clsName</span><span class="p">,</span><span class="n">clsRemark</span><span class="p">)</span> <span class="k">values</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nv">"JAVA一班"</span><span class="p">,</span><span class="nv">"JAVA一班"</span><span class="p">);</span>
    <span class="k">insert</span> <span class="k">INTO</span> <span class="n">tb_cls</span><span class="p">(</span><span class="n">clsId</span><span class="p">,</span><span class="n">clsName</span><span class="p">,</span><span class="n">clsRemark</span><span class="p">)</span> <span class="k">values</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="nv">"JAVA二班"</span><span class="p">,</span><span class="nv">"JAVA二班"</span><span class="p">);</span>
    <span class="k">insert</span> <span class="k">into</span> <span class="n">tb_cls</span><span class="p">(</span><span class="n">clsId</span><span class="p">,</span><span class="n">clsName</span><span class="p">,</span><span class="n">clsRemark</span><span class="p">)</span> <span class="k">values</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="nv">"JAVA三班"</span><span class="p">,</span><span class="nv">"JAVA三班"</span><span class="p">);</span>
</code></pre></div></div>

<p>【创建学生表】</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">create</span> <span class="k">table</span> <span class="n">tb_student</span><span class="p">(</span>
     <span class="n">stuId</span> <span class="nb">int</span>  <span class="k">primary</span> <span class="k">key</span> <span class="n">auto_increment</span>  <span class="k">COMMENT</span> <span class="s1">'学生编号'</span><span class="p">,</span>
	 <span class="n">stuName</span> <span class="nb">varchar</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span> <span class="k">UNIQUE</span> <span class="k">COMMENT</span>  <span class="s1">'学生姓名'</span><span class="p">,</span>
	 <span class="n">stuAge</span> <span class="nb">int</span> <span class="k">COMMENT</span> <span class="s1">'学生年龄'</span><span class="p">,</span>
	 <span class="n">stuSex</span> <span class="nb">char</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="k">DEFAULT</span> <span class="s1">'1'</span> <span class="k">COMMENT</span> <span class="s1">'学生性别'</span><span class="p">,</span>
	 <span class="n">stuHobby</span> <span class="nb">varchar</span><span class="p">(</span><span class="mi">255</span><span class="p">)</span> <span class="k">COMMENT</span> <span class="s1">'学生爱好'</span><span class="p">,</span>
     <span class="n">clsId</span> <span class="nb">int</span>  <span class="k">comment</span> <span class="s1">'班级编号'</span><span class="p">,</span>
      <span class="o">#</span><span class="err">添加外键</span>
	 <span class="k">FOREIGN</span> <span class="k">key</span><span class="p">(</span><span class="n">clsId</span><span class="p">)</span> <span class="k">REFERENCES</span> <span class="n">tb_cls</span><span class="p">(</span><span class="n">clsId</span><span class="p">)</span>
<span class="p">)</span>
<span class="k">insert</span> <span class="k">into</span> <span class="n">tb_student</span><span class="p">(</span><span class="n">stuName</span><span class="p">,</span><span class="n">stuAge</span><span class="p">,</span><span class="n">stuSex</span><span class="p">,</span><span class="n">stuHobby</span><span class="p">,</span><span class="n">clsId</span><span class="p">)</span> <span class="k">values</span><span class="p">(</span><span class="s1">'小明1'</span><span class="p">,</span><span class="mi">22</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="nv">"DOTA"</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
<span class="k">insert</span> <span class="k">into</span> <span class="n">tb_student</span><span class="p">(</span><span class="n">stuName</span><span class="p">,</span><span class="n">stuAge</span><span class="p">,</span><span class="n">stuSex</span><span class="p">,</span><span class="n">stuHobby</span><span class="p">,</span><span class="n">clsId</span><span class="p">)</span> <span class="k">values</span><span class="p">(</span><span class="s1">'小明2'</span><span class="p">,</span><span class="mi">22</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="nv">"DOTA"</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span>
<span class="k">insert</span> <span class="k">into</span> <span class="n">tb_student</span><span class="p">(</span><span class="n">stuName</span><span class="p">,</span><span class="n">stuAge</span><span class="p">,</span><span class="n">stuSex</span><span class="p">,</span><span class="n">stuHobby</span><span class="p">,</span><span class="n">clsId</span><span class="p">)</span> <span class="k">values</span><span class="p">(</span><span class="s1">'小明3'</span><span class="p">,</span><span class="mi">22</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="nv">"DOTA"</span><span class="p">,</span><span class="mi">3</span><span class="p">);</span>
<span class="k">insert</span> <span class="k">into</span> <span class="n">tb_student</span><span class="p">(</span><span class="n">stuName</span><span class="p">,</span><span class="n">stuAge</span><span class="p">,</span><span class="n">stuSex</span><span class="p">,</span><span class="n">stuHobby</span><span class="p">,</span><span class="n">clsId</span><span class="p">)</span> <span class="k">values</span><span class="p">(</span><span class="s1">'小明4'</span><span class="p">,</span><span class="mi">22</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="nv">"DOTA"</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
<span class="k">insert</span> <span class="k">into</span> <span class="n">tb_student</span><span class="p">(</span><span class="n">stuName</span><span class="p">,</span><span class="n">stuAge</span><span class="p">,</span><span class="n">stuSex</span><span class="p">,</span><span class="n">stuHobby</span><span class="p">,</span><span class="n">clsId</span><span class="p">)</span> <span class="k">values</span><span class="p">(</span><span class="s1">'小明5'</span><span class="p">,</span><span class="mi">22</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="nv">"DOTA"</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span>
<span class="k">insert</span> <span class="k">into</span> <span class="n">tb_student</span><span class="p">(</span><span class="n">stuName</span><span class="p">,</span><span class="n">stuAge</span><span class="p">,</span><span class="n">stuSex</span><span class="p">,</span><span class="n">stuHobby</span><span class="p">,</span><span class="n">clsId</span><span class="p">)</span> <span class="k">values</span><span class="p">(</span><span class="s1">'小明6'</span><span class="p">,</span><span class="mi">22</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="nv">"DOTA"</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
</code></pre></div></div>

<p>关于一对多和多对一的删除问题</p>

<p>默认情况，是如果对应的班级有学生，班级是不能删除</p>

<p>可以设置如果要删除的班级下面有学生，可以让学生也删除</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">create</span> <span class="k">table</span> <span class="n">tb_student</span><span class="p">(</span>
       <span class="n">stuId</span> <span class="nb">int</span>  <span class="k">primary</span> <span class="k">key</span> <span class="n">auto_increment</span>  <span class="k">COMMENT</span> <span class="s1">'学生编号'</span><span class="p">,</span>
    	 <span class="n">stuName</span> <span class="nb">varchar</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span> <span class="k">UNIQUE</span> <span class="k">COMMENT</span>  <span class="s1">'学生姓名'</span><span class="p">,</span>
    	 <span class="n">stuAge</span> <span class="nb">int</span> <span class="k">COMMENT</span> <span class="s1">'学生年龄'</span><span class="p">,</span>
    	 <span class="n">stuSex</span> <span class="nb">char</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="k">DEFAULT</span> <span class="s1">'1'</span> <span class="k">COMMENT</span> <span class="s1">'学生性别'</span><span class="p">,</span>
    	 <span class="n">stuHobby</span> <span class="nb">varchar</span><span class="p">(</span><span class="mi">255</span><span class="p">)</span> <span class="k">COMMENT</span> <span class="s1">'学生爱好'</span><span class="p">,</span>
       <span class="n">clsId</span> <span class="nb">int</span>  <span class="k">comment</span> <span class="s1">'班级编号'</span><span class="p">,</span>
			 <span class="o">#</span><span class="err">添加外键</span>
			 <span class="k">FOREIGN</span> <span class="k">key</span><span class="p">(</span><span class="n">clsId</span><span class="p">)</span> <span class="k">REFERENCES</span> <span class="n">tb_cls</span><span class="p">(</span><span class="n">clsId</span><span class="p">)</span>  <span class="k">ON</span> <span class="k">DELETE</span> <span class="k">CASCADE</span>
    <span class="p">)</span>
</code></pre></div></div>

<p>可以设置如果要删除的班级下面有学生，让学生的班级编号设置为null</p>

<pre><code class="language-mysql">create table tb_student(
       stuId int  primary key auto_increment  COMMENT '学生编号',
    	 stuName varchar(20) UNIQUE COMMENT  '学生姓名',
    	 stuAge int COMMENT '学生年龄',
    	 stuSex char(1) DEFAULT '1' COMMENT '学生性别',
    	 stuHobby varchar(255) COMMENT '学生爱好',
       clsId int  comment '班级编号',
			 #添加外键
			 FOREIGN key(clsId) REFERENCES tb_cls(clsId)  ON DELETE CASCADE
			 	#|--如果一方被删除，那么多方法引用的数据也会被删除
    )
</code></pre>

<p>【使用工具如何设置】</p>

<p><img src="/数据库/1637310079835.png" /></p>

<h2 id="83-多对多many-to-many掌握">8.3 多对多（many-to-many）【掌握】</h2>

<p>总结，多对多的关系必须建立中间表</p>

<p>中间表的里要使用联合主键+外键的规则</p>

<pre><code class="language-mysql">

#一对多和多对一
以学生和班级为例

【创建班级表】

    create table tb_cls(
       clsId int primary key auto_increment  comment '班级编号',
       clsName varchar(20) UNIQUE comment '班级名称',
       clsRemark varchar(50) comment '班级备注'
    )
    insert into tb_cls(clsId,clsName,clsRemark) values(1,"JAVA一班","JAVA一班");
    insert INTO tb_cls(clsId,clsName,clsRemark) values(2,"JAVA二班","JAVA二班");
    insert into tb_cls(clsId,clsName,clsRemark) values(3,"JAVA三班","JAVA三班");

【创建学生表】

    create table tb_student(
stuId int  primary key auto_increment COMMENT '学生编号',
stuName varchar(20) UNIQUE COMMENT  '学生姓名',
stuAge int COMMENT '学生年龄',
stuSex char(1) DEFAULT '1' COMMENT '学生性别',
stuHobby varchar(255) COMMENT '学生爱好',
clsId int  comment '班级编号'
#添加外键
FOREIGN key(clsId) REFERENCES tb_cls(clsId)  ON DELETE RESTRICT
    )
    insert into tb_student(stuName,stuAge,stuSex,stuHobby,clsId) values('小明',22,1,"DOTA",1);
    insert into tb_student(stuName,stuAge,stuSex,stuHobby,clsId) values('小荭',22,1,"DOTA",2);
    insert into tb_student(stuName,stuAge,stuSex,stuHobby,clsId) values('小丽',22,1,"DOTA",3);
    insert into tb_student(stuName,stuAge,stuSex,stuHobby,clsId) values('小芳',22,1,"DOTA",1);
    insert into tb_student(stuName,stuAge,stuSex,stuHobby,clsId) values('小花',22,1,"DOTA",2);
    insert into tb_student(stuName,stuAge,stuSex,stuHobby,clsId) values('小美',22,1,"DOTA",1);

#现在是1-3号班级都有数据

# 创建一个科目表
create table tb_course(
  course_id int(11) auto_increment COMMENT '课程编号',
  course_name varchar(30) not null comment '课程名称',
  primary key(course_id)
)

#创建一个学生和课程的关系表（一个学生可以选多个课 |一个课可以让多个学生选择）
create table tb_student_course(
	stuId int ,
	course_id int ,
    score int,
	#联合主键的建立
	primary key(stuId,course_id),
	#建立stuId的外键
	FOREIGN key(stuId) REFERENCES tb_student(stuId),
	#建立course_id的外键
	FOREIGN key(course_id) REFERENCES tb_course(course_id));
#小明[1]选择了JAVA[1] 分数为100分
insert into tb_student_course(stuId,course_id,score) values(1,1,100)
#小明[1]选择了PHP[2] 分数为100分
insert into tb_student_course(stuId,course_id,score) values(1,2,100)
# 下面的数据添加不进去，原因是10号学生不存在，违反的外键规则
insert into tb_student_course(stuId,course_id,score) values(10,2,100)
</code></pre>

<h2 id="84-员工系统设计">8.4 员工系统设计</h2>

<h3 id="841-要求">8.4.1 要求</h3>

<p>​	1，可以记录员工信息EMP</p>

<p>​	2，可以记录公司所有的部门信息DEPT</p>

<p>​	3，可以记录工资等级信息SALGRAGE</p>

<h3 id="842-部门表dept">8.4.2 <strong>部门表（dept）</strong></h3>

<table>
  <thead>
    <tr>
      <th><strong>№</strong></th>
      <th><strong>名称</strong></th>
      <th><strong>类型</strong></th>
      <th><strong>描述</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>1</strong></td>
      <td><strong>DEPTNO</strong></td>
      <td><strong>INT</strong></td>
      <td><strong>表示部门编号</strong></td>
    </tr>
    <tr>
      <td><strong>2</strong></td>
      <td><strong>DNAME</strong></td>
      <td><strong>VARCHAR(</strong><strong>20</strong><strong>)</strong></td>
      <td><strong>部门名称，最多由</strong><strong>20</strong><strong>个字符所组成</strong></td>
    </tr>
    <tr>
      <td><strong>3</strong></td>
      <td><strong>LOC</strong></td>
      <td><strong>VARCHAR(</strong><strong>20</strong><strong>)</strong></td>
      <td><strong>部门所在的位置</strong></td>
    </tr>
  </tbody>
</table>

<h3 id="843-员工表emp">8.4.3 <strong>员工表（emp）</strong></h3>

<table>
  <thead>
    <tr>
      <th><strong>№</strong></th>
      <th><strong>名称</strong></th>
      <th><strong>类型</strong></th>
      <th><strong>描述</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>1</strong></td>
      <td><strong>EMPNO</strong></td>
      <td><strong>INT</strong></td>
      <td><strong>雇员的编号</strong> <strong>主键</strong></td>
    </tr>
    <tr>
      <td><strong>2</strong></td>
      <td><strong>ENAME</strong></td>
      <td><strong>VARCHAR(10)</strong></td>
      <td><strong>雇员的姓名</strong></td>
    </tr>
    <tr>
      <td><strong>4</strong></td>
      <td><strong>MGR</strong></td>
      <td><strong>INT</strong></td>
      <td><strong>雇员对应的领导编号，领导也是雇员</strong></td>
    </tr>
    <tr>
      <td><strong>5</strong></td>
      <td><strong>HIREDATE</strong></td>
      <td><strong>DATE</strong></td>
      <td><strong>雇员的雇佣日期</strong></td>
    </tr>
    <tr>
      <td><strong>6</strong></td>
      <td><strong>JOB</strong></td>
      <td><strong>VARCHAR(10)</strong></td>
      <td><strong>职位</strong></td>
    </tr>
    <tr>
      <td><strong>7</strong></td>
      <td><strong>SAL</strong></td>
      <td><strong>decimal</strong><strong>(7,2)</strong></td>
      <td><strong>基本工资，其中有两位小数，五倍整数，一共是七位</strong></td>
    </tr>
    <tr>
      <td><strong>8</strong></td>
      <td><strong>COMM</strong></td>
      <td><strong>decimal(7,2)</strong></td>
      <td><strong>奖金，佣金</strong></td>
    </tr>
    <tr>
      <td><strong>9</strong></td>
      <td><strong>DEPTNO</strong></td>
      <td><strong>INT</strong></td>
      <td><strong>雇员所在的部门编号</strong></td>
    </tr>
  </tbody>
</table>

<h3 id="844-工资等级表salgrade">8.4.4 <strong>工资等级表（salgrade）</strong></h3>

<table>
  <thead>
    <tr>
      <th><strong>№</strong></th>
      <th><strong>名称</strong></th>
      <th><strong>类型</strong></th>
      <th><strong>描述</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>1</strong></td>
      <td><strong>GRADE</strong></td>
      <td><strong>INT</strong></td>
      <td><strong>工资的等级</strong>  <strong>主键</strong></td>
    </tr>
    <tr>
      <td><strong>2</strong></td>
      <td><strong>LOSAL</strong></td>
      <td><strong>decimal(7,2)</strong></td>
      <td><strong>此等级的最低工资</strong></td>
    </tr>
    <tr>
      <td><strong>3</strong></td>
      <td><strong>HISAL</strong></td>
      <td><strong>decimal(7,2)</strong></td>
      <td><strong>此等级的最高工资</strong></td>
    </tr>
  </tbody>
</table>

<h3 id="845-脚本">8.4.5 脚本</h3>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- ----------------------------</span>
<span class="c1">-- 创建部门表</span>
<span class="c1">-- ----------------------------</span>
<span class="k">DROP</span> <span class="k">TABLE</span> <span class="n">IF</span> <span class="k">EXISTS</span> <span class="n">dept</span><span class="p">;</span>
<span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">dept</span>  <span class="p">(</span>
  <span class="n">DEPTNO</span> <span class="nb">int</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span> <span class="k">NOT</span> <span class="k">NULL</span> <span class="k">COMMENT</span> <span class="s1">'部门编号'</span><span class="p">,</span>
  <span class="n">DNAME</span> <span class="nb">varchar</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span> <span class="k">NOT</span> <span class="k">NULL</span> <span class="k">COMMENT</span> <span class="s1">'部门名称'</span><span class="p">,</span>
  <span class="n">LOC</span> <span class="nb">varchar</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>  <span class="k">COMMENT</span> <span class="s1">'部门所在的位置'</span><span class="p">,</span>
  <span class="k">PRIMARY</span> <span class="k">KEY</span> <span class="p">(</span><span class="n">DEPTNO</span><span class="p">)</span>
<span class="p">)</span> <span class="n">ENGINE</span> <span class="o">=</span> <span class="n">InnoDB</span> <span class="nb">CHARACTER</span> <span class="k">SET</span> <span class="o">=</span> <span class="n">utf8mb4</span>  <span class="k">COMMENT</span> <span class="o">=</span> <span class="s1">'部门表'</span><span class="p">;</span>
<span class="c1">-- ----------------------------</span>
<span class="c1">-- 创建员工表</span>
<span class="c1">-- ----------------------------</span>
<span class="k">DROP</span> <span class="k">TABLE</span> <span class="n">IF</span> <span class="k">EXISTS</span> <span class="n">emp</span><span class="p">;</span>
<span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">emp</span>  <span class="p">(</span>
  <span class="n">EMPNO</span> <span class="nb">int</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span> <span class="k">NOT</span> <span class="k">NULL</span> <span class="k">COMMENT</span> <span class="s1">'雇员的编号'</span><span class="p">,</span>
  <span class="n">ENAME</span> <span class="nb">varchar</span><span class="p">(</span><span class="mi">50</span><span class="p">)</span>  <span class="k">NOT</span> <span class="k">NULL</span> <span class="k">COMMENT</span> <span class="s1">'雇员的姓名'</span><span class="p">,</span>
<span class="n">JOB</span> 	<span class="nb">varchar</span><span class="p">(</span><span class="mi">50</span><span class="p">)</span>  <span class="k">NOT</span> <span class="k">NULL</span> <span class="k">COMMENT</span> <span class="s1">'职位'</span><span class="p">,</span>
  <span class="n">MGR</span> <span class="nb">int</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span> <span class="k">NULL</span> <span class="k">DEFAULT</span> <span class="k">NULL</span> <span class="k">COMMENT</span> <span class="s1">'雇员对应的领导编号'</span><span class="p">,</span>
  <span class="n">HIREDATE</span> <span class="nb">date</span> <span class="k">NULL</span> <span class="k">DEFAULT</span> <span class="k">NULL</span> <span class="k">COMMENT</span> <span class="s1">'雇员的雇佣日期'</span><span class="p">,</span>
  <span class="n">SAL</span> <span class="nb">decimal</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="k">NULL</span> <span class="k">DEFAULT</span> <span class="k">NULL</span> <span class="k">COMMENT</span> <span class="s1">'基本工资'</span><span class="p">,</span>
  <span class="n">COMM</span> <span class="nb">decimal</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="k">NULL</span> <span class="k">DEFAULT</span> <span class="k">NULL</span> <span class="k">COMMENT</span> <span class="s1">'奖金，佣金'</span><span class="p">,</span>
  <span class="n">DEPTNO</span> <span class="nb">int</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span> <span class="k">NULL</span> <span class="k">DEFAULT</span> <span class="k">NULL</span> <span class="k">COMMENT</span> <span class="s1">'雇员所在的部门编号'</span><span class="p">,</span>
  <span class="k">PRIMARY</span> <span class="k">KEY</span> <span class="p">(</span><span class="n">EMPNO</span><span class="p">),</span>
  <span class="k">CONSTRAINT</span> <span class="n">FK_EMP_DEPTNO</span> <span class="k">FOREIGN</span> <span class="k">KEY</span> <span class="p">(</span><span class="n">DEPTNO</span><span class="p">)</span> <span class="k">REFERENCES</span> <span class="n">dept</span> <span class="p">(</span><span class="n">DEPTNO</span><span class="p">)</span> <span class="k">ON</span> <span class="k">DELETE</span> <span class="k">RESTRICT</span> <span class="k">ON</span> <span class="k">UPDATE</span> <span class="k">RESTRICT</span>
<span class="p">)</span> <span class="n">ENGINE</span> <span class="o">=</span> <span class="n">InnoDB</span> <span class="nb">CHARACTER</span> <span class="k">SET</span> <span class="o">=</span> <span class="n">utf8mb4</span> <span class="k">COMMENT</span> <span class="o">=</span> <span class="s1">'员工表'</span><span class="p">;</span>

<span class="c1">-- ----------------------------</span>
<span class="c1">-- 工资等级表</span>
<span class="c1">-- ----------------------------</span>
<span class="k">DROP</span> <span class="k">TABLE</span> <span class="n">IF</span> <span class="k">EXISTS</span> <span class="n">salgrade</span><span class="p">;</span>
<span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">salgrade</span>  <span class="p">(</span>
  <span class="n">GRADE</span> <span class="nb">int</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span> <span class="k">NOT</span> <span class="k">NULL</span> <span class="k">COMMENT</span> <span class="s1">'工资的等级  主键'</span><span class="p">,</span>
  <span class="n">LOSAL</span> <span class="nb">decimal</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="k">NOT</span> <span class="k">NULL</span> <span class="k">COMMENT</span> <span class="s1">'此等级的最低工资'</span><span class="p">,</span>
  <span class="n">HISAL</span> <span class="nb">decimal</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="k">NOT</span> <span class="k">NULL</span> <span class="k">COMMENT</span> <span class="s1">'此等级的最高工资'</span><span class="p">,</span>
  <span class="k">PRIMARY</span> <span class="k">KEY</span> <span class="p">(</span><span class="n">GRADE</span><span class="p">)</span>
<span class="p">)</span> <span class="n">ENGINE</span> <span class="o">=</span> <span class="n">InnoDB</span> <span class="nb">CHARACTER</span> <span class="k">SET</span> <span class="o">=</span> <span class="n">utf8mb4</span>  <span class="k">COMMENT</span> <span class="o">=</span> <span class="s1">'工资等级表'</span> <span class="p">;</span>



<span class="c1">-- ----------------------------</span>
<span class="c1">-- 部门表插入数据</span>
<span class="c1">-- ----------------------------</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">DEPT</span> <span class="k">VALUES</span> <span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="s1">'财务部'</span><span class="p">,</span> <span class="s1">'武汉'</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">DEPT</span> <span class="k">VALUES</span> <span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="s1">'研发部'</span><span class="p">,</span> <span class="s1">'武汉'</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">DEPT</span> <span class="k">VALUES</span> <span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="s1">'销售部'</span><span class="p">,</span> <span class="s1">'深圳'</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">DEPT</span> <span class="k">VALUES</span> <span class="p">(</span><span class="mi">40</span><span class="p">,</span> <span class="s1">'业务部'</span><span class="p">,</span> <span class="s1">'上海'</span><span class="p">);</span>
<span class="c1">-- ----------------------------</span>
<span class="c1">-- 员工表插入数据</span>
<span class="c1">-- ----------------------------</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">EMP</span>  <span class="k">values</span> <span class="p">(</span><span class="mi">7369</span><span class="p">,</span> <span class="s1">'SMITH'</span><span class="p">,</span> <span class="s1">'CLERK'</span><span class="p">,</span> <span class="mi">7902</span><span class="p">,</span> <span class="s1">'1980-12-17'</span><span class="p">,</span> <span class="mi">800</span><span class="p">.</span><span class="mi">00</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="mi">20</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">EMP</span>  <span class="k">values</span> <span class="p">(</span><span class="mi">7499</span><span class="p">,</span> <span class="s1">'ALLEN'</span><span class="p">,</span> <span class="s1">'SALESMAN'</span><span class="p">,</span> <span class="mi">7698</span><span class="p">,</span> <span class="s1">'1981-02-20'</span><span class="p">,</span> <span class="mi">1600</span><span class="p">.</span><span class="mi">00</span><span class="p">,</span> <span class="mi">300</span><span class="p">.</span><span class="mi">00</span><span class="p">,</span> <span class="mi">30</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">EMP</span>  <span class="k">values</span> <span class="p">(</span><span class="mi">7521</span><span class="p">,</span> <span class="s1">'WARD'</span><span class="p">,</span> <span class="s1">'SALESMAN'</span><span class="p">,</span> <span class="mi">7698</span><span class="p">,</span> <span class="s1">'1981-02-22'</span><span class="p">,</span> <span class="mi">1250</span><span class="p">.</span><span class="mi">00</span><span class="p">,</span> <span class="mi">500</span><span class="p">.</span><span class="mi">00</span><span class="p">,</span> <span class="mi">30</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">EMP</span>  <span class="k">values</span> <span class="p">(</span><span class="mi">7566</span><span class="p">,</span> <span class="s1">'JONES'</span><span class="p">,</span> <span class="s1">'MANAGER'</span><span class="p">,</span> <span class="mi">7839</span><span class="p">,</span> <span class="s1">'1981-04-02'</span><span class="p">,</span> <span class="mi">2975</span><span class="p">.</span><span class="mi">00</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="mi">20</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">EMP</span>  <span class="k">values</span> <span class="p">(</span><span class="mi">7654</span><span class="p">,</span> <span class="s1">'MARTIN'</span><span class="p">,</span> <span class="s1">'SALESMAN'</span><span class="p">,</span> <span class="mi">7698</span><span class="p">,</span> <span class="s1">'1981-09-28'</span><span class="p">,</span> <span class="mi">1250</span><span class="p">.</span><span class="mi">00</span><span class="p">,</span> <span class="mi">1400</span><span class="p">.</span><span class="mi">00</span><span class="p">,</span> <span class="mi">30</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">EMP</span>  <span class="k">values</span> <span class="p">(</span><span class="mi">7698</span><span class="p">,</span> <span class="s1">'BLAKE'</span><span class="p">,</span> <span class="s1">'MANAGER'</span><span class="p">,</span> <span class="mi">7839</span><span class="p">,</span> <span class="s1">'1981-05-01'</span><span class="p">,</span> <span class="mi">2850</span><span class="p">.</span><span class="mi">00</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="mi">30</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">EMP</span>  <span class="k">values</span> <span class="p">(</span><span class="mi">7782</span><span class="p">,</span> <span class="s1">'CLARK'</span><span class="p">,</span> <span class="s1">'MANAGER'</span><span class="p">,</span> <span class="mi">7839</span><span class="p">,</span> <span class="s1">'1981-06-09'</span><span class="p">,</span> <span class="mi">2450</span><span class="p">.</span><span class="mi">00</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">EMP</span>  <span class="k">values</span> <span class="p">(</span><span class="mi">7788</span><span class="p">,</span> <span class="s1">'SCOTT'</span><span class="p">,</span> <span class="s1">'ANALYST'</span><span class="p">,</span> <span class="mi">7566</span><span class="p">,</span> <span class="s1">'1987-04-19'</span><span class="p">,</span> <span class="mi">3000</span><span class="p">.</span><span class="mi">00</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="mi">20</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">EMP</span>  <span class="k">values</span> <span class="p">(</span><span class="mi">7839</span><span class="p">,</span> <span class="s1">'KING'</span><span class="p">,</span> <span class="s1">'PRESIDENT'</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="s1">'1981-11-17'</span><span class="p">,</span> <span class="mi">5000</span><span class="p">.</span><span class="mi">00</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">EMP</span>  <span class="k">values</span> <span class="p">(</span><span class="mi">7844</span><span class="p">,</span> <span class="s1">'TURNER'</span><span class="p">,</span> <span class="s1">'SALESMAN'</span><span class="p">,</span> <span class="mi">7698</span><span class="p">,</span> <span class="s1">'1981-09-08'</span><span class="p">,</span> <span class="mi">1500</span><span class="p">.</span><span class="mi">00</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">00</span><span class="p">,</span> <span class="mi">30</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">EMP</span>  <span class="k">values</span> <span class="p">(</span><span class="mi">7876</span><span class="p">,</span> <span class="s1">'ADAMS'</span><span class="p">,</span> <span class="s1">'CLERK'</span><span class="p">,</span> <span class="mi">7788</span><span class="p">,</span> <span class="s1">'1987-05-23'</span><span class="p">,</span> <span class="mi">1100</span><span class="p">.</span><span class="mi">00</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="mi">20</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">EMP</span>  <span class="k">values</span> <span class="p">(</span><span class="mi">7900</span><span class="p">,</span> <span class="s1">'JAMES'</span><span class="p">,</span> <span class="s1">'CLERK'</span><span class="p">,</span> <span class="mi">7698</span><span class="p">,</span> <span class="s1">'1981-12-03'</span><span class="p">,</span> <span class="mi">950</span><span class="p">.</span><span class="mi">00</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="mi">30</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">EMP</span>  <span class="k">values</span> <span class="p">(</span><span class="mi">7902</span><span class="p">,</span> <span class="s1">'FORD'</span><span class="p">,</span> <span class="s1">'ANALYST'</span><span class="p">,</span> <span class="mi">7566</span><span class="p">,</span> <span class="s1">'1981-12-03'</span><span class="p">,</span> <span class="mi">3000</span><span class="p">.</span><span class="mi">00</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="mi">20</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">EMP</span>  <span class="k">values</span> <span class="p">(</span><span class="mi">7934</span><span class="p">,</span> <span class="s1">'MILLER'</span><span class="p">,</span> <span class="s1">'CLERK'</span><span class="p">,</span> <span class="mi">7782</span><span class="p">,</span> <span class="s1">'1982-01-23'</span><span class="p">,</span> <span class="mi">1300</span><span class="p">.</span><span class="mi">00</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
<span class="c1">-- ----------------------------</span>
<span class="c1">-- 工资等级表插入数据</span>
<span class="c1">-- ----------------------------</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">SALGRADE</span> <span class="p">(</span><span class="n">GRADE</span><span class="p">,</span> <span class="n">LOSAL</span><span class="p">,</span> <span class="n">HISAL</span><span class="p">)</span> <span class="k">values</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">700</span><span class="p">,</span> <span class="mi">1200</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">SALGRADE</span> <span class="p">(</span><span class="n">GRADE</span><span class="p">,</span> <span class="n">LOSAL</span><span class="p">,</span> <span class="n">HISAL</span><span class="p">)</span> <span class="k">values</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1201</span><span class="p">,</span> <span class="mi">1400</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">SALGRADE</span> <span class="p">(</span><span class="n">GRADE</span><span class="p">,</span> <span class="n">LOSAL</span><span class="p">,</span> <span class="n">HISAL</span><span class="p">)</span> <span class="k">values</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1401</span><span class="p">,</span> <span class="mi">2000</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">SALGRADE</span> <span class="p">(</span><span class="n">GRADE</span><span class="p">,</span> <span class="n">LOSAL</span><span class="p">,</span> <span class="n">HISAL</span><span class="p">)</span> <span class="k">values</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2001</span><span class="p">,</span> <span class="mi">3000</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">SALGRADE</span> <span class="p">(</span><span class="n">GRADE</span><span class="p">,</span> <span class="n">LOSAL</span><span class="p">,</span> <span class="n">HISAL</span><span class="p">)</span> <span class="k">values</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">3001</span><span class="p">,</span> <span class="mi">9999</span><span class="p">);</span>
</code></pre></div></div>

<h1 id="9单表数据查询">9，单表数据查询</h1>

<p>查询是MYSQL学习里面最重要的环节</p>

<h3 id="sql语句的注释">sql语句的注释</h3>

<p>SQL中的注释分为单行注释和多行注释。顾名思义，单行注释就是对一行进行注释，多行注释就是同时对多行进行注释。</p>

<p>一、单行注释</p>

<pre><code class="language-mysql">SQL语句中的单行注释使用 –

create database database_x    --创建数据库database_x
1
</code></pre>

<p>二、多行注释</p>

<pre><code class="language-mysql">SQL语句中的多行注释采用 /…/

create database database_x
/*
    创建一个数据库
    名字叫做database_x
*/
</code></pre>

<h2 id="91-最简单的查询方式">9.1 最简单的查询方式</h2>

<pre><code class="language-mysql">1，查询部门所有信息
SELECT * FROM DEPT;
2，查询所有部门的部门编号和名称
SELECT DEPTNO,DNAME FROM DEPT;
3,查询所有员工信息
SELECT * FROM EMP;
4,查询所有员的名字和入职时间
SELECT ENAME,HIREDATE FROM EMP;
</code></pre>

<h2 id="92-使用算术表达式">9.2 使用算术表达式</h2>

<pre><code class="language-mysql">1,查询所有员工名字和工资，并在原有的工资基础加10%
SELECT ENAME,SAL*1.1 FROM EMP;
2,查询所有员工名字和工资，并在原有的工资基础减10%
SELECT ENAME,SAL*0.9 FROM EMP;
3,查询所有员工名字和工资，并在原有的工资基础加1000
SELECT ENAME,SAL+1000 FROM EMP;
4,查询所有员工名字和工资，并在原有的工资基础减500
SELECT ENAME,SAL-500 FROM EMP;
</code></pre>

<h2 id="93-使用字段别名">9.3 使用字段别名</h2>

<pre><code class="language-mysql">1，查询所有部门信息并翻译表头
SELECT DEPTNO AS '部门 编号',DNAME AS 部门名称,LOC AS 部门地址 FROM  DEPT;
2,在SQL查询中，AS可以不写
SELECT DEPTNO  '部门 编号',DNAME  部门名称,LOC  部门地址 FROM  DEPT;
</code></pre>

<h2 id="94-去重查询distinct">9.4 去重查询DISTINCT</h2>

<pre><code class="language-mysql">1，查询所有员工的部门编号
SELECT DEPTNO FROM EMP;
2,过虑上一个查询部门编号
SELECT DISTINCT DEPTNO FROM EMP;
3,查询所有员工的部门编号和工种[JOB]
SELECT JOB,DEPTNO FROM EMP;
4,过虑上一个查询的数据
SELECT DISTINCT JOB,DEPTNO FROM EMP;
</code></pre>

<h2 id="95-排序查询-order-by">9.5 排序查询 ORDER BY</h2>

<pre><code class="language-mysql">1，查询所有员工信息，并按工资升序【ASC--可以不写】
SELECT * FROM EMP ORDER BY SAL ASC
2，查询所有员工信息，并按工资降序【DESC】
SELECT * FROM EMP ORDER BY SAL DESC
3,查询所有员工信息，并按工资降序【DESC】 如果工资相同，按入职时间升序
SELECT * FROM EMP ORDER BY SAL DESC ,HIREDATE ASC
</code></pre>

<h2 id="96-分页查询limit">9.6 分页查询LIMIT</h2>

<pre><code class="language-mysql">1,查询员工的前三条数
SELECT * FROM EMP LIMIT 3;
2, 真正的分页查询 应该有页码   每页条数

pageNum  页码
pageSize 每页的条数
          pageNum       pageSize
第一页       1            5
第二页       2            5
第三页       3            5
SELECT * FROM EMP;
SELECT * FROM EMP LIMIT A,B  # 第一页的查询
SELECT * FROM EMP LIMIT 0,5  # 第一页的查询
SELECT * FROM EMP LIMIT 5,5  # 第二页的查询
SELECT * FROM EMP LIMIT 10,5  # 第三页的查询

算
A =(pageNum-1)*pageSize    A是指从第一条开始的便宜量
B =pageSize
</code></pre>

<h2 id="97-合并查询-union">9.7 **合并查询 **UNION</h2>

<pre><code class="language-mysql">1,查询部门编号为10的员工
SELECT * FROM EMP WHERE DEPTNO=10;
2,查询部门编号为30的员工
SELECT * FROM EMP WHERE DEPTNO=30;
3,把上面两个查询的结果合并到一起
SELECT * FROM EMP WHERE DEPTNO=10
UNION
SELECT * FROM EMP WHERE DEPTNO=30;
4,查询部门编号为10或者20的员工
SELECT * FROM EMP WHERE DEPTNO=10 OR DEPTNO=20;
5，查询部门编号20的员工
SELECT * FROM EMP WHERE DEPTNO=20;
6,把4和5的查询结构进行合并
SELECT * FROM EMP WHERE DEPTNO=10 OR DEPTNO=20
UNION  #合并并去重
SELECT * FROM EMP WHERE DEPTNO=20
7,把4和5的查询结构进行合并 不去重
SELECT * FROM EMP WHERE DEPTNO=10 OR DEPTNO=20
UNION ALL  #只合并，不去重
SELECT * FROM EMP WHERE DEPTNO=20
8，如果字段名不一样，可不可以合并[--不可以]
SELECT EMPNO,ENAME,SAL FROM EMP
UNION
SELECT JOB,SAL,DEPTNO FROM EMP
#合并的原则，只要两个查询结果列数一样就可以合并
</code></pre>

<h1 id="10where子句">10，WHERE子句</h1>

<p>作用：对查询结果进行筛选</p>

<h2 id="101-用法举例">10.1 <strong>用法举例</strong></h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>select * from emp where deptno=10;  #查询所有部门ID=10的员工
select * from emp where ename = 'JACK';#查询名字等于JACK的员工
select * from emp where hiredate = '2020-12-12';  查询入职时间为2020-12-12的工
</code></pre></div></div>

<p>注意：</p>

<p>字符串和日期值要用<strong>单引号</strong>扩起来</p>

<p>字符串大小写敏感</p>

<p>日期值格式敏感，缺省的日期格式是<strong>‘YYYY-MM-DD HH:mm:ss’</strong></p>

<h2 id="102-查询条件中可以使用比较运算符">10.2 <strong>查询条件中可以使用比较运算符</strong></h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt;   &gt;=  &lt;  &lt;=  != &lt;&gt;  =
</code></pre></div></div>

<p><img src="/数据库/wpsC62.tmp.jpg" /></p>

<p>注意：MySQL使用=运算符来判断表达式是否相等，它没有==</p>

<p>​      Java使用!=表示不等于，MySQL也支持。但是我们不要使用，效率太低了</p>

<p>​      MySQL使用的不等于使用<strong>&lt;&gt;</strong></p>

<pre><code class="language-mysql">#1，比较运算符
1,查询工资大于2500的所有员工
SELECT * FROM EMP WHERE SAL&gt;2500;
2,查询部门编号不等于20的员工
SELECT * FROM EMP WHERE DEPTNO&lt;&gt;20
3,查询工资在800-1100之间的员工信息
SELECT * FROM EMP WHERE SAL BETWEEN 800 AND 1100;
	||
SELECT * FROM EMP WHERE SAL&gt;=800 AND SAL &lt;=1100;
4,查询JOB 为 CLERK SALESMAN MANAGER的员工
SELECT * FROM EMP WHERE JOB IN('CLERK','SALESMAN','MANAGER')



</code></pre>

<h2 id="103-使用like运算符执行模糊查询通配查询">10.3 使用LIKE运算符执行模糊查询（通配查询）</h2>

<p>LIKE  像</p>

<pre><code class="language-mysql">1,查询出所有员工里面名字以S开头的
SELECT * FROM EMP WHERE ENAME LIKE 'S%'
2,查询出所有员工里面名字包含S的
SELECT * FROM EMP WHERE ENAME LIKE '%S%'
3,查询出所有员工里面字以S开头，并且名字长度为5的员工
SELECT * FROM EMP WHERE ENAME LIKE 'S____';
</code></pre>

<h2 id="104-使用is-null运算符进行空值判断">10.4 使用IS NULL运算符进行空值判断</h2>

<pre><code class="language-mysql">1,查询所有员工里面奖金为NULL的员工
SELECT * FROM EMP WHERE COMM IS NULL;
2,查询所有员工里面部门编号为30 并且奖金不为空的
SELECT * FROM EMP WHERE DEPTNO=30 AND COMM IS NOT NULL;
</code></pre>

<h2 id="105-查询条件中可以使用逻辑运算符">10.5 查询条件中可以使用逻辑运算符</h2>

<pre><code class="language-mysql">and  前后的条件都为true
or   前后的条件满足一个就可以了
in(1,2,3,4,5) 在XX里面 以集合里面的所有数据进行等值判断
not in(1,2,3,4,5) 不在集合里面  对集合里面的所有数据做&lt;&gt;判断
</code></pre>

<pre><code class="language-mysql">1,查询员工表里面部门编号为10 并且工资大于1000
select * from emp where deptno = 10 and sal &gt; 1000;
2，查询员工表里面部门编号为10 或者 JOB 为 CLERK
select * from emp where deptno = 10 or job = ‘CLERK’;
||
select * from emp where deptno = 10
UNION
select * from emp where job = ‘CLERK’;
3,查询员工工资不在800, 1500, 2000里面的员工信息
SELECT * FROM EMP WHERE SAL NOT IN(800, 1500, 2000)
</code></pre>

<h3 id="sql优化问题">SQL优化问题</h3>

<pre><code class="language-mysql">AND:  把检索结果较少的条件放到后面
OR:  把检索结果较多的条件放到后面
</code></pre>

<h2 id="106-四种运算符优先级算术连接比较逻辑">10.6 四种运算符优先级：算术&gt;连接&gt;比较&gt;逻辑</h2>

<p><img src="/数据库/wpsF8A.tmp.jpg" /></p>

<pre><code class="language-mysql">可使用小括号强行改变运算顺序
select * from emp where job='SALESMAN' or job='CLERK' and sal&gt;=1280;
select * from emp where (job='SALESMAN' or job='CLERK') and sal&gt;=1280;
</code></pre>

<h1 id="11-聚合函数">11 聚合函数</h1>

<p>使用函数可以大大提高SELECT语句操作数据库的能力。它给数据的转换和处理提供了方便。</p>

<p>函数只是将取出的数据进行处理，不会改变数据库中的值。</p>

<h2 id="111-函数的分类">11.1 函数的分类</h2>

<p>本质就是方法</p>

<h3 id="1111-单行函数">11.1.1 单行函数</h3>

<p>对表里面的某一个字段进行处理</p>

<p><strong>Ø 数学函数</strong></p>

<p><strong>Ø 字符串函数</strong></p>

<p><strong>Ø 日期和时间函数</strong></p>

<p><strong>Ø 条件判断函数</strong></p>

<p>Ø 系统信息函数</p>

<p>Ø 加密函数</p>

<p>Ø 格式化函数</p>

<h3 id="1112-多行函数">11.1.2 多行函数</h3>

<p>对表里面某一组字段数据进行数据</p>

<p>仅适用数值型的多行函数</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> sum() 求和
 avg() 求平均值
</code></pre></div></div>

<p>适用任何类型数据</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>count() 计数
max() 求最大值
min() 求最小值
</code></pre></div></div>

<h2 id="112-单行函数">11.2 <strong>单行函数</strong></h2>

<h3 id="1121-数学函数">11.2.1 数学函数</h3>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">（</span><span class="mi">1</span><span class="err">）</span><span class="k">ABS</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="err">返回</span><span class="n">x</span><span class="err">的绝对值</span>
<span class="k">SELECT</span> <span class="k">ABS</span><span class="p">(</span><span class="o">-</span><span class="mi">10</span><span class="p">);</span>
<span class="err">（</span><span class="mi">2</span><span class="err">）</span><span class="n">PI</span><span class="p">()</span>  <span class="err">返回圆周率π，默认显示</span><span class="mi">6</span><span class="err">位小数</span>
<span class="k">SELECT</span> <span class="n">PI</span><span class="p">();</span>
<span class="err">（</span><span class="mi">3</span><span class="err">）</span><span class="n">SQRT</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  <span class="err">返回非负数的</span><span class="n">x</span><span class="err">的二次方根</span>
<span class="k">SELECT</span> <span class="n">SQRT</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span>
<span class="err">（</span><span class="mi">4</span><span class="err">）</span><span class="k">MOD</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>  <span class="err">返回</span><span class="n">x</span><span class="err">被</span><span class="n">y</span><span class="err">除后的余数</span>
<span class="k">SELECT</span> <span class="k">MOD</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span>
<span class="err">（</span><span class="mi">5</span><span class="err">）</span><span class="n">CEIL</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="err">向上取整</span>
<span class="k">SELECT</span> <span class="n">CEIL</span><span class="p">(</span><span class="mi">9</span><span class="p">.</span><span class="mi">000001</span><span class="p">);</span>
<span class="err">（</span><span class="mi">6</span><span class="err">）</span><span class="n">FLOOR</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  <span class="err">向下取整</span>
<span class="k">SELECT</span> <span class="n">FLOOR</span><span class="p">(</span><span class="mi">9</span><span class="p">.</span><span class="mi">99999999</span><span class="p">);</span>
<span class="err">（</span><span class="mi">7</span><span class="err">）</span><span class="n">ROUND</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="err">、</span><span class="n">ROUND</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>  <span class="err">前者返回最接近于</span><span class="n">x</span><span class="err">的整数，即对</span><span class="n">x</span><span class="err">进行四舍五入；后者返回最接近</span><span class="n">x</span><span class="err">的数，其值保留到小数点后面</span><span class="n">y</span><span class="err">位，若</span><span class="n">y</span><span class="err">为负值，则将保留到</span><span class="n">x</span><span class="err">到小数点左边</span><span class="n">y</span><span class="err">位</span>
<span class="k">SELECT</span> <span class="n">ROUND</span><span class="p">(</span><span class="mi">4</span><span class="p">.</span><span class="mi">51312312</span><span class="p">);</span>
<span class="k">SELECT</span> <span class="n">ROUND</span><span class="p">(</span><span class="mi">4</span><span class="p">.</span><span class="mi">51312312</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span>
<span class="err">（</span><span class="mi">8</span><span class="err">）</span><span class="n">POW</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span><span class="err">和、</span><span class="n">POWER</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>  <span class="err">返回</span><span class="n">x</span><span class="err">的</span><span class="n">y</span><span class="err">次乘方的值</span>
<span class="k">SELECT</span> <span class="n">POW</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
<span class="err">（</span><span class="mi">9</span><span class="err">）</span><span class="n">RAND</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>   <span class="err">返回</span><span class="mi">0</span><span class="o">-</span><span class="mi">1</span><span class="err">之间的随机小数</span>  <span class="n">X</span><span class="err">是种子值</span> <span class="err">如果定死那么返回的值就是一样的</span>
<span class="k">SELECT</span> <span class="n">RAND</span><span class="p">();</span>
<span class="err">（</span><span class="mi">10</span><span class="err">）查询员工数据，返回员工名字和工资</span>  <span class="err">并对工资向上取整</span>
<span class="k">SELECT</span> <span class="n">ENAME</span><span class="p">,</span><span class="n">CEIL</span><span class="p">(</span><span class="n">SAL</span><span class="p">)</span> <span class="k">AS</span> <span class="n">SAL</span> <span class="k">FROM</span> <span class="n">EMP</span><span class="p">;</span>
</code></pre></div></div>

<h3 id="1121-字符串函数">11.2.1 字符串函数</h3>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">（</span><span class="mi">1</span><span class="err">）</span><span class="k">CHAR_LENGTH</span><span class="p">(</span><span class="n">str</span><span class="p">)</span>  <span class="err">计算字符串字符个数</span>
		<span class="k">SELECT</span> <span class="k">CHAR_LENGTH</span><span class="p">(</span><span class="nv">"HELLO"</span><span class="p">);</span>
    <span class="o">|</span><span class="c1">--查询员工表里面员工姓名及员工的姓名的字符长度</span>
		<span class="k">SELECT</span> <span class="n">ENAME</span><span class="p">,</span><span class="k">CHAR_LENGTH</span><span class="p">(</span><span class="n">ENAME</span><span class="p">)</span> <span class="k">FROM</span> <span class="n">EMP</span> <span class="p">;</span>
		<span class="o">|</span><span class="c1">--查询员工表里面员工姓名长度为5的员工的所有信息</span>
		<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">EMP</span> <span class="k">WHERE</span> <span class="k">CHAR_LENGTH</span><span class="p">(</span><span class="n">ENAME</span><span class="p">)</span><span class="o">=</span><span class="mi">5</span>
<span class="err">（</span><span class="mi">2</span><span class="err">）</span><span class="n">CONCAT</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span><span class="n">s2</span><span class="err">，</span><span class="p">...)</span>  <span class="err">返回连接参数产生的字符串，一个或多个待拼接的内容，任意一个为</span><span class="k">NULL</span><span class="err">则返回值为</span><span class="k">NULL</span>
	 <span class="k">SELECT</span> <span class="n">CONCAT</span><span class="p">(</span><span class="s1">'A'</span><span class="p">,</span><span class="s1">'B'</span><span class="p">,</span><span class="s1">'C'</span><span class="p">);</span>
	 <span class="o">|</span><span class="c1">--查询员的表里面的数据 要求把员工ID和员的姓名使用-连接在一起</span>
			<span class="k">SELECT</span> <span class="n">CONCAT</span><span class="p">(</span><span class="n">EMPNO</span><span class="p">,</span><span class="s1">'-'</span><span class="p">,</span><span class="n">ENAME</span><span class="p">)</span> <span class="k">FROM</span> <span class="n">EMP</span> <span class="p">;</span>
<span class="err">（</span><span class="mi">3</span><span class="err">）</span><span class="n">CONCAT_WS</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">s1</span><span class="p">,</span><span class="n">s2</span><span class="p">,...)</span> <span class="err">返回多个字符串拼接之后的字符串，每个字符串之间有一个</span><span class="n">x</span>
   <span class="k">SELECT</span> <span class="n">CONCAT_WS</span><span class="p">(</span><span class="s1">'-'</span><span class="p">,</span><span class="s1">'A'</span><span class="p">,</span><span class="s1">'B'</span><span class="p">,</span><span class="s1">'C'</span><span class="p">);</span>
	 <span class="o">|</span><span class="c1">--查询员的表里面的数据 要求把员工ID和员的姓名使用-连接在一起</span>
			<span class="k">SELECT</span> <span class="n">CONCAT_WS</span><span class="p">(</span><span class="s1">'-'</span><span class="p">,</span><span class="n">EMPNO</span><span class="p">,</span><span class="n">ENAME</span><span class="p">)</span> <span class="k">FROM</span> <span class="n">EMP</span> <span class="p">;</span>
<span class="err">（</span><span class="mi">4</span><span class="err">）</span><span class="k">LOWER</span><span class="p">(</span><span class="n">str</span><span class="p">)</span><span class="k">UPPER</span><span class="p">(</span><span class="n">str</span><span class="p">)</span><span class="err">前两者将</span><span class="n">str</span><span class="err">中的字母全部转换成小写，后两者将字符串中的字母全部转换成大写</span>
	<span class="k">SELECT</span> <span class="k">LOWER</span><span class="p">(</span><span class="s1">'HELLO'</span><span class="p">);</span>
	<span class="k">SELECT</span> <span class="k">UPPER</span><span class="p">(</span><span class="s1">'hellO'</span><span class="p">);</span>
<span class="err">（</span><span class="mi">5</span><span class="err">）</span><span class="k">TRIM</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>  <span class="err">返回字符串</span><span class="n">s</span><span class="err">删除了两边空格之后的字符串</span>
<span class="k">SELECT</span> <span class="k">TRIM</span><span class="p">(</span><span class="s1">'   ABC     '</span><span class="p">)</span>
<span class="err">（</span><span class="mi">6</span><span class="err">）</span><span class="k">REPLACE</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">s1</span><span class="p">,</span><span class="n">s2</span><span class="p">)</span>  <span class="err">返回一个字符串，用字符串</span><span class="n">s2</span><span class="err">替代字符串</span><span class="n">s</span><span class="err">中所有的字符串</span><span class="n">s1</span>
<span class="k">SELECT</span> <span class="k">REPLACE</span><span class="p">(</span><span class="s1">'hello world'</span><span class="p">,</span><span class="s1">'l'</span><span class="p">,</span><span class="s1">'L'</span><span class="p">);</span>
<span class="err">（</span><span class="mi">7</span><span class="err">）</span><span class="k">SUBSTRING</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">len</span><span class="p">)</span><span class="err">两个函数作用相同，从字符串</span><span class="n">s</span><span class="err">中返回一个第</span><span class="n">n</span><span class="err">个字符开始、长度为</span><span class="n">len</span><span class="err">的字符串</span>
<span class="k">SELECT</span> <span class="k">SUBSTRING</span><span class="p">(</span><span class="nv">"HELLO WORLD"</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span>
	<span class="o">|</span><span class="c1">--查询所有员的的名字 并取出员工名字的第一个字母  并转成小写</span>
		<span class="k">SELECT</span> <span class="k">SUBSTRING</span><span class="p">(</span><span class="n">ENAME</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="k">FROM</span> <span class="n">EMP</span><span class="p">;</span>
		<span class="k">SELECT</span> <span class="k">LOWER</span><span class="p">(</span><span class="k">SUBSTRING</span><span class="p">(</span><span class="n">ENAME</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span> <span class="k">FROM</span> <span class="n">EMP</span><span class="p">;</span>
<span class="err">（</span><span class="mi">8</span><span class="err">）</span><span class="n">REVERSE</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>  <span class="err">将字符串</span><span class="n">s</span><span class="err">反转</span>
	<span class="k">SELECT</span> <span class="n">REVERSE</span><span class="p">(</span><span class="nv">"HELLO"</span><span class="p">);</span>


</code></pre></div></div>

<h3 id="1121-日期和时间函数">11.2.1 日期和时间函数</h3>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">（</span><span class="mi">1</span><span class="err">）</span><span class="n">CURDATE</span><span class="p">()</span><span class="err">、</span><span class="k">CURRENT_DATE</span><span class="p">()</span><span class="err">将当前日期按照</span><span class="nv">"YYYY-MM-DD"</span><span class="err">或者</span><span class="nv">"YYYYMMDD"</span><span class="err">格式的值返回，具体格式根据函数用在字符串或是数字语境中而定</span>
<span class="k">SELECT</span> <span class="n">CURDATE</span><span class="p">(),</span><span class="k">CURRENT_DATE</span><span class="p">();</span>
<span class="err">（</span><span class="mi">2</span><span class="err">）</span><span class="k">CURRENT_TIMESTAMP</span><span class="p">()</span><span class="err">、</span><span class="k">LOCALTIME</span><span class="p">()</span><span class="err">、</span><span class="n">NOW</span><span class="p">()</span><span class="err">、</span><span class="n">SYSDATE</span><span class="p">()</span><span class="err">这四个函数作用相同，返回当前日期和时间值，格式为</span><span class="nv">"YYYY_MM-DD HH:MM:SS"</span><span class="err">或</span><span class="nv">"YYYYMMDDHHMMSS"</span><span class="err">，具体格式根据函数用在字符串或数字语境中而定</span>
<span class="k">SELECT</span> <span class="k">CURRENT_TIMESTAMP</span><span class="p">(),</span><span class="k">LOCALTIME</span><span class="p">(),</span><span class="n">NOW</span><span class="p">(),</span><span class="n">SYSDATE</span><span class="p">();</span>

<span class="err">（</span><span class="mi">3</span><span class="err">）</span><span class="k">MONTH</span><span class="p">(</span><span class="nb">date</span><span class="p">)</span><span class="err">和</span><span class="n">MONTHNAME</span><span class="p">(</span><span class="nb">date</span><span class="p">)</span><span class="err">前者返回指定日期中的月份，后者返回指定日期中的月份的名称</span>
<span class="k">SELECT</span> <span class="k">MONTH</span><span class="p">(</span><span class="n">SYSDATE</span><span class="p">())</span> <span class="p">,</span><span class="n">MONTHNAME</span><span class="p">(</span><span class="n">SYSDATE</span><span class="p">());</span>

<span class="err">（</span><span class="mi">4</span><span class="err">）</span><span class="n">WEEK</span><span class="p">(</span><span class="n">d</span><span class="p">)</span><span class="err">、</span><span class="n">WEEKOFYEAR</span><span class="p">(</span><span class="n">d</span><span class="p">)</span><span class="err">前者计算日期</span><span class="n">d</span><span class="err">是一年中的第几周，后者计算某一天位于一年中的第几周</span>
<span class="k">SELECT</span> <span class="n">WEEK</span><span class="p">(</span><span class="s1">'2021-11-11'</span><span class="p">),</span><span class="n">WEEKOFYEAR</span><span class="p">(</span><span class="s1">'2021-11-11'</span><span class="p">)</span>
<span class="err">（</span><span class="mi">5</span><span class="err">）</span><span class="n">DAYOFYEAR</span><span class="p">(</span><span class="n">d</span><span class="p">)</span><span class="err">、</span><span class="n">DAYOFMONTH</span><span class="p">(</span><span class="n">d</span><span class="p">)</span><span class="err">前者返回</span><span class="n">d</span><span class="err">是一年中的第几天，后者返回</span><span class="n">d</span><span class="err">是一月中的第几天</span>
<span class="k">SELECT</span> <span class="n">DAYOFYEAR</span><span class="p">(</span><span class="n">NOW</span><span class="p">()),</span><span class="n">DAYOFMONTH</span><span class="p">(</span><span class="n">NOW</span><span class="p">());</span>
<span class="err">（</span><span class="mi">6</span><span class="err">）</span><span class="k">EXTRACT</span><span class="p">(</span><span class="k">type</span> <span class="k">FROM</span> <span class="nb">date</span><span class="p">)</span><span class="err">从日期中提取一部分，</span><span class="k">type</span><span class="err">可以是</span><span class="nb">YEAR</span><span class="err">、</span><span class="n">YEAR_MONTH</span><span class="err">、</span><span class="k">MONTH</span><span class="err">、</span><span class="k">DAY</span><span class="err">、</span><span class="n">DAY_HOUR</span><span class="err">、</span><span class="n">DAY_MINUTE</span><span class="err">、</span><span class="n">DAY_SECOND</span><span class="err">、</span><span class="n">DAY_MICROSECOND</span><span class="err">、</span>
<span class="k">SELECT</span> <span class="k">EXTRACT</span><span class="p">(</span><span class="nb">YEAR</span> <span class="k">FROM</span> <span class="n">NOW</span><span class="p">()),</span><span class="k">EXTRACT</span><span class="p">(</span><span class="n">YEAR_MONTH</span> <span class="k">FROM</span> <span class="n">NOW</span><span class="p">()),</span><span class="k">EXTRACT</span><span class="p">(</span><span class="k">MONTH</span> <span class="k">FROM</span> <span class="n">NOW</span><span class="p">()),</span><span class="k">EXTRACT</span><span class="p">(</span><span class="k">DAY</span> <span class="k">FROM</span> <span class="n">NOW</span><span class="p">());</span>
<span class="err">（</span><span class="mi">7</span><span class="err">）</span><span class="n">TimeStampDiff</span><span class="p">(</span><span class="err">间隔类型，前一个日期，后一个日期</span><span class="p">)</span>
<span class="err">例如距离现在差了多少年：</span><span class="n">TimeStampDiff</span><span class="p">(</span><span class="nb">year</span><span class="p">,</span> <span class="err">前一个日期</span><span class="p">,</span> <span class="n">now</span><span class="p">())</span>
<span class="err">间隔类型有：</span><span class="k">second</span><span class="err">秒，</span><span class="k">minute</span><span class="err">分，</span><span class="n">hour</span><span class="err">时，</span><span class="k">day</span><span class="err">天，</span><span class="n">week</span><span class="err">周，</span><span class="k">month</span><span class="err">月，</span><span class="n">quarter</span><span class="err">季度，</span><span class="nb">year</span><span class="err">年</span>
<span class="k">SELECT</span> <span class="n">TimeStampDiff</span><span class="p">(</span><span class="k">month</span><span class="p">,</span><span class="s1">'1990-1-3'</span><span class="p">,</span><span class="n">NOW</span><span class="p">())</span>
<span class="err">作业：计算</span><span class="n">EMP</span><span class="err">表里面</span><span class="mi">35</span><span class="err">年前入职的员工</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">EMP</span> <span class="k">WHERE</span> <span class="n">TimeStampDiff</span><span class="p">(</span><span class="nb">year</span><span class="p">,</span><span class="n">HIREDATE</span><span class="p">,</span><span class="n">NOW</span><span class="p">())</span><span class="o">&gt;</span><span class="mi">35</span><span class="p">;</span>
<span class="err">（</span><span class="mi">8</span><span class="err">）</span><span class="n">DATE_ADD</span><span class="p">(</span><span class="nb">date</span><span class="p">,</span><span class="n">INTERVAL</span> <span class="n">expr</span> <span class="k">type</span><span class="p">)</span><span class="err">、</span><span class="n">ADD_DATE</span><span class="p">(</span><span class="nb">date</span><span class="p">,</span><span class="n">INTERVAL</span> <span class="n">expr</span> <span class="k">type</span><span class="p">)</span><span class="err">返回将起始时间加上</span><span class="n">expr</span> <span class="k">type</span><span class="err">之后的时间，</span>
   <span class="err">比如</span><span class="n">DATE_ADD</span><span class="p">(</span><span class="s1">'2010-12-31 23:59:59'</span><span class="p">,</span> <span class="n">INTERVAL</span> <span class="mi">1</span> <span class="k">SECOND</span><span class="p">)</span><span class="err">表示的就是把第一个时间加</span><span class="mi">1</span><span class="err">秒</span>

   <span class="err">比如</span><span class="n">DATE_ADD</span><span class="p">(</span><span class="s1">'2021-11-20 23:59:59'</span><span class="p">,</span> <span class="n">INTERVAL</span> <span class="mi">1</span> <span class="k">SECOND</span><span class="p">)</span><span class="err">表示的就是把第一个时间加</span><span class="mi">1</span><span class="err">秒</span>

	<span class="k">SELECT</span> 	<span class="n">DATE_ADD</span><span class="p">(</span><span class="s1">'2021-11-20 23:59:59'</span><span class="p">,</span> <span class="n">INTERVAL</span> <span class="mi">1</span> <span class="nb">YEAR</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="1121-if条件判断函数">11.2.1 if条件判断函数</h3>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">（</span><span class="mi">1</span><span class="err">）</span><span class="n">IF</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span><span class="n">v1</span><span class="p">,</span><span class="n">v2</span><span class="p">)</span><span class="err">如果</span><span class="n">expr</span><span class="err">是</span><span class="k">TRUE</span><span class="err">则返回</span><span class="n">v1</span><span class="err">，否则返回</span><span class="n">v2</span>
<span class="k">SELECT</span> <span class="n">IF</span><span class="p">(</span><span class="mi">1</span><span class="o">&gt;</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span>
    <span class="err">查询员工表里面的数据，如果奖金为空就显示</span><span class="mi">0</span><span class="p">.</span><span class="mi">00</span>
		<span class="k">SELECT</span> <span class="n">ENAME</span><span class="p">,</span><span class="n">JOB</span><span class="p">,</span><span class="n">SAL</span><span class="p">,</span><span class="n">IF</span><span class="p">(</span><span class="n">COMM</span> <span class="k">IS</span> <span class="k">NULL</span><span class="p">,</span><span class="mi">0</span><span class="p">.</span><span class="mi">00</span><span class="p">,</span><span class="n">COMM</span><span class="p">)</span> <span class="k">FROM</span> <span class="n">EMP</span><span class="p">;</span>
<span class="err">（</span><span class="mi">2</span><span class="err">）</span><span class="n">IFNULL</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span><span class="n">v2</span><span class="p">)</span><span class="err">函数</span>  <span class="err">如果</span><span class="n">v1</span><span class="err">的值不为</span><span class="k">NULL</span><span class="err">，则返回</span><span class="n">v1</span><span class="err">，否则返回</span><span class="n">v2</span><span class="err">。</span>
	    <span class="err">查询员工表里面的数据，如果奖金为空就显示</span><span class="mi">0</span><span class="p">.</span><span class="mi">00</span>
		<span class="k">SELECT</span> <span class="n">ENAME</span><span class="p">,</span><span class="n">JOB</span><span class="p">,</span><span class="n">SAL</span><span class="p">,</span><span class="n">IFNULL</span><span class="p">(</span><span class="n">COMM</span><span class="p">,</span><span class="mi">0</span><span class="p">.</span><span class="mi">00</span><span class="p">)</span> <span class="k">FROM</span> <span class="n">EMP</span><span class="p">;</span>
<span class="err">（</span><span class="mi">2</span><span class="err">）</span><span class="k">CASE</span> <span class="n">expr</span> <span class="k">WHEN</span> <span class="n">v1</span> <span class="k">THEN</span> <span class="n">r1</span> <span class="p">[</span><span class="k">WHEN</span> <span class="n">v2</span> <span class="k">THEN</span> <span class="n">v2</span><span class="p">]</span> <span class="p">[</span><span class="k">ELSE</span> <span class="n">rn</span><span class="p">]</span> <span class="k">END</span> <span class="err">如果</span><span class="n">expr</span><span class="err">等于某个</span><span class="n">vn</span><span class="err">，则返回对应位置</span><span class="k">THEN</span><span class="err">后面的结果，如果与所有值都不想等，则返回</span><span class="k">ELSE</span><span class="err">后面的</span><span class="n">rn</span>
	 <span class="k">SELECT</span> <span class="k">CASE</span> <span class="mi">4</span> <span class="k">WHEN</span>  <span class="mi">1</span> <span class="k">THEN</span> <span class="s1">'第一名'</span> <span class="k">WHEN</span> <span class="mi">2</span> <span class="k">THEN</span> <span class="s1">'第二名'</span> <span class="k">ELSE</span> <span class="s1">'第三名'</span> <span class="k">END</span><span class="p">;</span>
	 <span class="o">|</span><span class="c1">--查询员的信息里面的JOB ，要求把JOB翻译成中文</span>
	 <span class="k">SELECT</span> <span class="n">ENAME</span><span class="p">,</span><span class="n">JOB</span><span class="p">,</span>
			<span class="k">CASE</span> <span class="n">JOB</span>
			<span class="k">WHEN</span> <span class="s1">'CLERK'</span> <span class="k">THEN</span> <span class="s1">'职员'</span>
			<span class="k">WHEN</span> <span class="s1">'SALESMAN'</span> <span class="k">THEN</span> <span class="s1">'销售员'</span>
			<span class="k">WHEN</span> <span class="s1">'MANAGER'</span> <span class="k">THEN</span> <span class="s1">'经理'</span>
			<span class="k">WHEN</span> <span class="s1">'ANALYST'</span> <span class="k">THEN</span> <span class="s1">'财务'</span>
			<span class="k">WHEN</span> <span class="s1">'PRESIDENT'</span> <span class="k">THEN</span> <span class="s1">'总经理'</span>
		  <span class="k">ELSE</span>  <span class="s1">'未知'</span>
			<span class="k">END</span>
	 <span class="k">FROM</span> <span class="n">EMP</span><span class="p">;</span>
</code></pre></div></div>

<h3 id="1121-系统函数">11.2.1 系统函数</h3>

<pre><code class="language-mysql">（1）VERSION()查看MySQL版本号
SELECT VERSION();
</code></pre>

<h3 id="1121-加密函数">11.2.1 加密函数</h3>

<pre><code class="language-mysql">（1）PASSWORD(str)从原明文密码str计算并返回加密后的字符串密码，注意这个函数的加密是单向的（不可逆），因此不应将它应用在个人的应用程序中而应该只在MySQL服务器的鉴定系统中使用
SELECT PASSWORD('123456')
</code></pre>

<h2 id="113-多行函数">11.3 多行函数</h2>

<p>对一组数据进行运算，针对一组数据（多行记录）只返回一个结果，也称分组函数</p>

<p><img src="/数据库/wps8575.tmp.jpg" /></p>

<h3 id="1131多行函数的作用">11.3.1，多行函数的作用</h3>

<p>对一组数据进行处理，返回一行一列的数据</p>

<h3 id="1132常用的多行函数">11.3.2，常用的多行函数</h3>

<p>sum()  avg()   仅适用数值型</p>

<p>count()   max()   min()   适用任何类型数据</p>

<h3 id="1133多行函数和空值及count的说明">11.3.3，多行函数和空值及count的说明</h3>

<pre><code class="language-mysql">多行函数除了count(*)外，都跳过空值而处理非空值
可使用IF()函数强制多行函数处理空值

count(*)返回组中总记录数目； 一般推荐使用count(1)
count(exp)返回表达式exp值非空的记录数目；
count(distinct(exp))返回表达式exp值不重复的、非空的记录数目。
</code></pre>

<h3 id="1134group-by-子句的使用">11.3.4，GROUP BY 子句的使用</h3>

<p>作用：将表中数据分成若干小组</p>

<p>语法</p>

<pre><code class="language-mysql">select 字段，[多行函数]
from [where]
group by [字段]
</code></pre>

<p>【注意事项】</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">出现在</span><span class="k">SELECT</span><span class="err">列表中的字段，如果不是包含在多行函数中，那么该字段必须同时在</span><span class="k">GROUP</span> <span class="k">BY</span><span class="err">子句中出现。</span>
<span class="err">错误：</span><span class="k">select</span> <span class="n">ename</span><span class="p">,</span><span class="n">deptno</span><span class="p">,</span><span class="k">sum</span><span class="p">(</span><span class="n">sal</span><span class="p">)</span> <span class="k">from</span> <span class="n">emp</span> <span class="k">group</span> <span class="k">by</span> <span class="n">deptno</span><span class="p">;</span>
<span class="o">|</span><span class="c1">--以上的SQL在MYSQL中是不错的，但是在oracle是错的，在开发中避免这样写</span>
<span class="err">包含在</span><span class="k">GROUP</span> <span class="k">BY</span><span class="err">子句中的字段则不必须出现在</span><span class="k">SELECT</span><span class="err">列表中。</span>

<span class="err">如果没有</span><span class="k">GROUP</span> <span class="k">BY</span><span class="err">子句，</span><span class="k">SELECT</span><span class="err">列表中不允许出现字段（单行函数）与多行函数混用的情况</span>
<span class="k">select</span> <span class="n">empno</span><span class="p">,</span> <span class="n">sal</span> <span class="k">from</span> <span class="n">emp</span><span class="p">;</span> <span class="o">//</span><span class="err">合法</span>
<span class="k">select</span> <span class="k">avg</span><span class="p">(</span><span class="n">sal</span><span class="p">)</span> <span class="k">from</span> <span class="n">emp</span><span class="p">;</span> <span class="o">//</span><span class="err">合法</span>
<span class="k">select</span> <span class="n">empno</span><span class="p">,</span> <span class="k">avg</span><span class="p">(</span><span class="n">sal</span><span class="p">)</span> <span class="k">from</span> <span class="n">emp</span><span class="p">;</span> <span class="o">//</span><span class="err">非法</span>
<span class="err">不允许在</span><span class="k">WHERE</span> <span class="err">子句中使用多行函数</span>
<span class="k">select</span> <span class="n">deptno</span><span class="p">,</span> <span class="k">avg</span><span class="p">(</span><span class="n">sal</span><span class="p">)</span>   <span class="k">from</span> <span class="n">emp</span>
<span class="k">where</span> <span class="k">avg</span><span class="p">(</span><span class="n">sal</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2000</span><span class="p">;</span>   <span class="o">//</span><span class="err">执行</span><span class="k">where</span><span class="err">时尚未执行</span><span class="n">groupby</span> <span class="err">及其他</span>
<span class="k">group</span> <span class="k">by</span> <span class="n">deptno</span><span class="p">;</span>
</code></pre></div></div>

<h3 id="1135haveing子句的使用">11.3.5，HAVEING子句的使用</h3>

<p>注意点：因为在Group by后现不能跟where子句，那么如果想对分组之后的结果进行过滤只能使用having</p>

<p>语法</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">select</span> <span class="err">字段，</span><span class="p">[</span><span class="err">多行函数</span><span class="p">]</span>
<span class="k">from</span> <span class="p">[</span><span class="k">where</span><span class="p">]</span>
<span class="k">group</span> <span class="k">by</span> <span class="p">[</span><span class="err">字段</span><span class="p">]</span>
<span class="k">having</span> <span class="p">[</span><span class="err">表达式</span><span class="p">]</span>
</code></pre></div></div>

<p>案例</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">5</span><span class="err">，按部门统计每个部门最高工资</span> <span class="err">最底工资，平均工资</span> <span class="err">并找出平均工资大于</span><span class="mi">2000</span><span class="err">的数据</span>
<span class="k">SELECT</span> <span class="n">DEPTNO</span><span class="p">,</span> <span class="k">MAX</span><span class="p">(</span><span class="n">SAL</span><span class="p">)</span> <span class="err">最高工资</span><span class="p">,</span><span class="k">MIN</span><span class="p">(</span><span class="n">SAL</span><span class="p">)</span> <span class="err">最低工资</span><span class="p">,</span><span class="k">AVG</span><span class="p">(</span><span class="n">SAL</span><span class="p">)</span> <span class="err">平均工资</span>  <span class="k">FROM</span> <span class="n">EMP</span> <span class="k">GROUP</span> <span class="k">BY</span> <span class="n">DEPTNO</span>  <span class="k">HAVING</span> <span class="err">平均工资</span><span class="o">&gt;</span><span class="mi">2000</span>
<span class="k">SELECT</span> <span class="n">DEPTNO</span><span class="p">,</span> <span class="k">MAX</span><span class="p">(</span><span class="n">SAL</span><span class="p">)</span> <span class="err">最高工资</span><span class="p">,</span><span class="k">MIN</span><span class="p">(</span><span class="n">SAL</span><span class="p">)</span> <span class="err">最低工资</span><span class="p">,</span><span class="k">AVG</span><span class="p">(</span><span class="n">SAL</span><span class="p">)</span> <span class="err">平均工资</span>  <span class="k">FROM</span> <span class="n">EMP</span> <span class="k">GROUP</span> <span class="k">BY</span> <span class="n">DEPTNO</span>  <span class="k">HAVING</span> <span class="k">AVG</span><span class="p">(</span><span class="n">SAL</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">2000</span>
</code></pre></div></div>

<h3 id="小练习">小练习</h3>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">统计人数小于</span><span class="mi">4</span><span class="err">的部门的平均工资。</span>
<span class="k">SELECT</span> <span class="n">DEPTNO</span><span class="p">,</span><span class="k">COUNT</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="err">人数</span><span class="p">,</span><span class="k">AVG</span><span class="p">(</span><span class="n">SAL</span><span class="p">)</span> <span class="err">平均工资</span> <span class="k">FROM</span> <span class="n">EMP</span>
<span class="k">GROUP</span> <span class="k">BY</span> <span class="n">DEPTNO</span> <span class="k">HAVING</span> <span class="err">人数</span><span class="o">&lt;</span><span class="mi">4</span>
<span class="err">统计各部门的最高工资，排除最高工资小于</span><span class="mi">8000</span><span class="err">的部门。</span>
<span class="k">SELECT</span> <span class="n">DEPTNO</span><span class="p">,</span><span class="k">MAX</span><span class="p">(</span><span class="n">SAL</span><span class="p">)</span> <span class="err">最高工资</span> <span class="k">FROM</span> <span class="n">EMP</span> <span class="k">GROUP</span> <span class="k">BY</span> <span class="n">DEPTNO</span> <span class="k">HAVING</span> <span class="err">最高工资</span><span class="o">&gt;=</span><span class="mi">8000</span>
<span class="err">显示部门编号大于</span><span class="mi">10</span> <span class="err">的部门的人数，要求人数大于</span><span class="mi">3</span>
<span class="k">SELECT</span> <span class="n">DEPTNO</span><span class="p">,</span><span class="k">COUNT</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="err">人数</span> <span class="k">FROM</span> <span class="n">EMP</span> <span class="k">GROUP</span> <span class="k">BY</span> <span class="n">DEPTNO</span> <span class="k">HAVING</span> <span class="err">人数</span><span class="o">&gt;</span><span class="mi">3</span> <span class="k">AND</span> <span class="n">DEPTNO</span><span class="o">&gt;</span><span class="mi">10</span><span class="p">;</span>
	<span class="o">|</span><span class="c1">--逻辑 先把所有数据按部门分组，再找出人数&gt;3和部门编号大于10的</span>
	<span class="o">|</span><span class="c1">--上面的不足，第一次就对所有数据进行分组【其它小于10的部门根本没有必须分组】</span>
	<span class="o">|</span><span class="c1">--修改之后的逻辑</span>
			<span class="o">|</span><span class="c1">--先找出部门编号大于10的所有员工，再进行分组</span>
	<span class="k">SELECT</span> <span class="n">DEPTNO</span><span class="p">,</span><span class="k">COUNT</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="err">人数</span> <span class="k">FROM</span> <span class="n">EMP</span> <span class="k">WHERE</span> <span class="n">DEPTNO</span><span class="o">&gt;</span><span class="mi">10</span> <span class="k">GROUP</span> <span class="k">BY</span> <span class="n">DEPTNO</span>
		<span class="k">HAVING</span> <span class="err">人数</span><span class="o">&gt;</span><span class="mi">3</span>
</code></pre></div></div>

<h1 id="12连接查询sql92">12，连接查询（SQL92）</h1>

<h2 id="121-为什么要连接查询">12.1 为什么要连接查询</h2>

<p>当用户需要的数据来源于多张表的时候，我们就需要使用连接查询</p>

<h2 id="122-连接查询概述">12.2 连接查询概述</h2>

<blockquote>
  <p>笛卡尔集</p>

  <p>等值连接</p>

  <p>非等值连接</p>

  <p>外连接</p>

  <p>自连接</p>
</blockquote>

<p>说明。SQL92是1992年提出的查询语法，向上兼容</p>

<h2 id="123-连接查询语法">12.3 连接查询语法</h2>

<h3 id="1231-语法规则">12.3.1 语法规则</h3>

<pre><code class="language-mysql">select table1.column,table2.column from table1,table2 where (连接条件)
</code></pre>

<h3 id="1232-特点">12.3.2 <strong>特点</strong></h3>

<p>在 WHERE 子句中写入连接条件</p>

<p>当多个表中有重名列时，必须在列的名字前加上表名作为前缀</p>

<h3 id="1233-连接的类型">12.3.3 <strong>连接的类型：</strong></h3>

<p>等值连接 – Equijoin</p>

<p>非等值连接 – Non-equijoin</p>

<p>左连接  –LEFT JOIN</p>

<p>右连接  –RIGHT JOIN</p>

<p>自连接 – Self join</p>

<h2 id="124-笛卡尔集">12.4 笛卡尔集</h2>

<pre><code class="language-mysql">select * from dept;//4条记录
select * from emp; //14条记录
select * from dept,emp; ;//4*14=56条记录
总结
检索出的行的数目将是第一个表中的行数乘以第二个表中的行数
检索出的列的数目将是第一个表中的列数加上第二个表中的列数
应该保证所有联结都有where子句，不然数据库返回比想要的数据多得多的数据 
</code></pre>

<h2 id="125-等值连接">12.5 等值连接</h2>

<p>上面的笛卡尔集的查询里面的数据很多不是合法的数据，而我们要找的数据是员工表的部门编号和部门表的部门编号相等数据【左边表的某一列必须和右边表的某一列相等】</p>

<pre><code class="language-mysql">1,要求查询员的信息并查询员的所有部门信息
SELECT EMP.*,DEPT.DNAME,DEPT.LOC FROM EMP,DEPT WHERE EMP.DEPTNO=DEPT.DEPTNO;
||--简化
SELECT T1.*,T2.DNAME,T2.LOC FROM EMP AS T1,DEPT AS T2 WHERE T1.DEPTNO=T2.DEPTNO;
||--再简化
SELECT T1.*,T2.DNAME,T2.LOC FROM EMP  T1,DEPT  T2 WHERE T1.DEPTNO=T2.DEPTNO;
2,要求查询工资大于2000员工信息并查询员的所有部门信息
SELECT T1.*,T2.DNAME,T2.LOC FROM EMP  T1,DEPT  T2 WHERE T1.DEPTNO=T2.DEPTNO AND T1.SAL&gt;2000;
</code></pre>

<h3 id="注意点">【注意点】</h3>

<table>
  <tbody>
    <tr>
      <td>当被连接的多个表中存在同名字段时，须在该字段前加上”表名</td>
      <td>另名.”前缀</td>
    </tr>
  </tbody>
</table>

<p>可使用AND 操作符增加查询条件；</p>

<p>使用表别名可以简化查询</p>

<p>使用表名（表别名）前缀可提高查询效率；</p>

<h2 id="126-非等值连接">12.6 非等值连接</h2>

<p>如查连接条件不是使用=去判断的就叫非等值连接</p>

<pre><code class="language-mysql">1,查询出员工的工资等级[salgrage]及员工信息[emp]
select t1.*,t2.* from emp t1,salgrade t2 where t1.sal&gt;=t2.losal and t1.sal&lt;=t2.hisal
||--等价写法
select t1.*,t2.* from emp t1,salgrade t2 where t1.sal between t2.losal and t2.hisal
</code></pre>

<h2 id="127-自连接">12.7 自连接</h2>

<p>特点：自己连接自己</p>

<p>何时使用：用户需要的数据来源同一张表的不同行</p>

<pre><code class="language-mysql">1,查询出员工信息及员的直接领导名字【差一条数据SQL92解决不了】
SELECT T1.*,T2.ENAME AS 领导名字 FROM EMP T1,EMP T2 WHERE T1.MGR=T2.EMPNO
</code></pre>

<h2 id="128-三表连查">12.8 三表连查</h2>

<pre><code class="language-mysql">综合
1，查询出员工信息[emp]，及部门名称[dept] 及员工的工资等级[salgrade]
SELECT T1.*,T2.DNAME,T3.GRADE FROM EMP T1,DEPT T2,SALGRADE T3
WHERE (T1.DEPTNO=T2.DEPTNO AND T1.SAL BETWEEN T3.LOSAL AND T3.HISAL)
</code></pre>

<h2 id="开发中的注意点">[开发中的注意点]</h2>

<blockquote>
  <p>如果不必使用连表查询就不用边表查询 ，尽量使用单表查询【性能问题】</p>

  <p>连接查询原则上对表的个是没有限制，但是开发中尽量不要超过5张表</p>
</blockquote>

<h1 id="13连接查询sql99">13，连接查询（SQL99）</h1>

<h2 id="11-sql99语法概述">1.1 <strong>SQL99语法概述</strong></h2>

<p><strong>SQL92的语法规则的缺点：</strong></p>

<p>语句过滤条件和表连接的条件都放到了where子句中 。</p>

<p>当条件过多时，联结条件多，过滤条件多时，就容易造成混淆</p>

<p><strong>SQL99修正了整个缺点，把联结条件，过滤条件分开来，包括以下新的TABLE JOIN的句法结构：</strong></p>

<p>交叉连接（Cross join）</p>

<p>自然连接（Natural join）</p>

<p>使用Using子句建立连接</p>

<p>使用On子句建立连接</p>

<p>连接（ Outer join ）</p>

<p>​		 内连接INNER JOIN</p>

<p>​		 左连接LEFT JOIN</p>

<p>​		右连接RIGHT JOIN</p>

<h2 id="132-语法">13.2 <strong>语法</strong></h2>

<pre><code class="language-mysql">select 字段列表
from table1
[cross join table2] |                                    //1：交叉连接
[natural join table2] |                                  //2：自然连接
[join table2 using (字段名)] |                      //3：using子句
[join table2 on (table1.column_name = table2.column_name)] | //4：on子句
[(left | right | full outer) join table2
on (table1.column_name = table2.column_name)]; //5：左/右/满外连接
WHERE 过滤条件
</code></pre>

<h2 id="133-交叉连接">13.3 交叉连接</h2>

<p>Cross join产生了一个笛卡尔集，其效果等同于在两个表进行连接时未使用WHERE子句限定连接条件;</p>

<p>可以使用where条件从笛卡尔集中选出满足条件的记录。</p>

<p>语法</p>

<pre><code class="language-mysql">select 字段列表
from  table1 cross join table 2
select 字段列表 from table1,table2  [sql92写]
</code></pre>

<h2 id="134-自然连接">13.4 自然连接</h2>

<pre><code class="language-mysql">Natural join基于两个表中的全部同名列建立等值连接
  从两个表中选出同名列做等值连接
  如果两个表中同名列的数据类型不同，则出错
  不允许在参照列上使用表名或者别名作为前缀
  自然连接的结果不保留重复的属性

 select empno, ename, sal, deptno, dname
from emp natural join dept
</code></pre>

<h2 id="135-using关键字">13.5 Using关键字</h2>

<p>如果不希望参照被连接表的所有同名列进行等值连接，自然连接将无法满足要求，可以在连接时使用USING子句来设置用于等值连接的列（参照列）名。</p>

<p>using子句引用的列在sql任何地方不能使用表名或者别名做前缀</p>

<pre><code class="language-mysql">SELECT * FROM EMP T1 JOIN DEPT T2 USING(DEPTNO);
</code></pre>

<h2 id="136-on子句">13.6 <strong>On子句</strong></h2>

<p>自然连接的条件是基于表中所有同名列的等值连接</p>

<p>为了设置任意的连接条件或者指定连接的列，需要使用ON子句</p>

<p>连接条件与其它的查询条件分开书写</p>

<p>使用ON 子句使查询语句更容易理解</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">查询出员工信息</span><span class="p">[</span><span class="n">emp</span><span class="p">]</span><span class="err">，及部门名称</span><span class="p">[</span><span class="n">dept</span><span class="p">]</span> <span class="err">及员工的工资等级</span><span class="p">[</span><span class="n">salgrade</span><span class="p">]</span> <span class="err">并只显示职位为</span> <span class="n">CLERK</span> <span class="n">SALESMAN</span> <span class="n">MANAGER</span>
<span class="k">SELECT</span> <span class="n">T1</span><span class="p">.</span><span class="o">*</span><span class="p">,</span><span class="n">T2</span><span class="p">.</span><span class="n">DNAME</span><span class="p">,</span><span class="n">T2</span><span class="p">.</span><span class="n">LOC</span> <span class="k">FROM</span> <span class="n">EMP</span> <span class="n">T1</span> <span class="k">JOIN</span> <span class="n">DEPT</span> <span class="n">T2</span> <span class="k">JOIN</span> <span class="n">salgrade</span> <span class="n">T3</span>
<span class="k">ON</span><span class="p">(</span><span class="n">T1</span><span class="p">.</span><span class="n">DEPTNO</span><span class="o">=</span><span class="n">T2</span><span class="p">.</span><span class="n">DEPTNO</span> <span class="k">AND</span> <span class="n">T1</span><span class="p">.</span><span class="n">SAL</span> <span class="k">BETWEEN</span> <span class="n">T3</span><span class="p">.</span><span class="n">LOSAL</span> <span class="k">AND</span> <span class="n">T3</span><span class="p">.</span><span class="n">HISAL</span><span class="p">)</span>
<span class="k">WHERE</span> <span class="n">T1</span><span class="p">.</span><span class="n">JOB</span> <span class="k">IN</span><span class="p">(</span><span class="s1">'CLERK'</span><span class="p">,</span><span class="s1">'SALESMAN'</span><span class="p">,</span><span class="s1">'MANAGER'</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="137-外连接">13.7 <strong>外连接</strong></h2>

<h3 id="1371-左外联接">13.7.1 <strong>左外联接</strong></h3>

<p>​    两个表在连接过程中除返回满足连接条件的行以外，还返回左表中不满足条件的行，这种连接称为左外联接。</p>

<h3 id="1372-右外联接">13.7.2 <strong>右外联接</strong></h3>

<p>​    两个表在连接过程中除返回满足连接条件的行以外，还返回右表中不满足条件的行，这种连接称为右外联接。</p>

<h3 id="1373-满外联接">13.7.3 <strong>满外联接</strong></h3>

<p>​    两个表在连接过程中除返回满足连接条件的行以外，还返回两个表中不满足条件的所有行，这种连接称为满外联接。</p>

<p>内连接:在SQL99规范中，内连接只返回满足连接条件的数据。</p>

<h3 id="1374-外连接举例">13.7.4 <strong>外连接举例</strong></h3>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">select</span> <span class="n">t1</span><span class="p">.</span><span class="n">deptno</span><span class="p">,</span> <span class="n">t1</span><span class="p">.</span><span class="n">dname</span><span class="p">,</span><span class="n">t2</span><span class="p">.</span><span class="n">empno</span><span class="p">,</span><span class="n">t2</span><span class="p">.</span><span class="n">ename</span> <span class="k">from</span> <span class="n">dept</span> <span class="n">t1</span> <span class="k">left</span> <span class="k">join</span> <span class="n">emp</span> <span class="n">t2</span> <span class="k">on</span><span class="p">(</span><span class="n">t1</span><span class="p">.</span><span class="n">deptno</span><span class="o">=</span><span class="n">t2</span><span class="p">.</span><span class="n">deptno</span><span class="p">);</span>
</code></pre></div></div>

<h1 id="14-子查询">14. <strong>子查询</strong></h1>

<h2 id="141-问题引入">14.1 <strong>问题引入</strong></h2>

<p>如何查得所有比“CLARK”工资高的员工的信息</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">如何查得所有比</span><span class="nv">"CLARK"</span><span class="err">工资高的员工的信息</span>
	<span class="mi">1</span><span class="p">,</span><span class="err">根据</span><span class="n">CLARK</span><span class="err">的名字找到他的工资</span>
	<span class="k">SELECT</span> <span class="n">SAL</span> <span class="k">FROM</span> <span class="n">EMP</span> <span class="k">WHERE</span> <span class="n">ENAME</span><span class="o">=</span><span class="s1">'CLARK'</span>
	<span class="mi">2</span><span class="p">,</span><span class="err">再拿着上一个查询的结果去所有数据里面比较</span>
	<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">EMP</span> <span class="k">WHERE</span> <span class="n">SAL</span> <span class="o">&gt;</span><span class="p">(</span><span class="k">SELECT</span> <span class="n">SAL</span> <span class="k">FROM</span> <span class="n">EMP</span> <span class="k">WHERE</span> <span class="n">ENAME</span><span class="o">=</span><span class="s1">'CLARK'</span><span class="p">)</span>
</code></pre></div></div>

<p>思考：查询工资高于平均工资的雇员名字和工资。</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">1</span><span class="p">,</span><span class="err">查询出平均工资</span>
<span class="k">SELECT</span> <span class="k">AVG</span><span class="p">(</span><span class="n">SAL</span><span class="p">)</span> <span class="k">FROM</span> <span class="n">EMP</span><span class="p">;</span>
<span class="mi">2</span><span class="p">,</span><span class="err">使用</span><span class="mi">1</span><span class="err">的结果再去查询所有员工进行比较</span>
<span class="k">SELECT</span> <span class="n">ENAME</span><span class="p">,</span><span class="n">SAL</span> <span class="k">FROM</span> <span class="n">EMP</span> <span class="k">WHERE</span> <span class="n">SAL</span><span class="o">&gt;</span><span class="p">(</span><span class="k">SELECT</span> <span class="k">AVG</span><span class="p">(</span><span class="n">SAL</span><span class="p">)</span> <span class="k">FROM</span> <span class="n">EMP</span><span class="p">)</span>
</code></pre></div></div>

<p>思考：查询和SCOTT同一部门且比他工资低的雇员名字和工资。</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">1</span><span class="err">，根据</span><span class="n">SCOTT</span><span class="err">的名字找到部门编号</span>
<span class="k">SELECT</span> <span class="n">DEPTNO</span> <span class="k">FROM</span> <span class="n">EMP</span> <span class="k">WHERE</span> <span class="n">ENAME</span> <span class="o">=</span><span class="s1">'SCOTT'</span>
<span class="mi">2</span><span class="err">，根据</span><span class="n">SCOTT</span><span class="err">的名字找到工资</span>
<span class="k">SELECT</span> <span class="n">SAL</span> <span class="k">FROM</span> <span class="n">EMP</span> <span class="k">WHERE</span> <span class="n">ENAME</span><span class="o">=</span><span class="s1">'SCOTT'</span>
<span class="mi">3</span><span class="err">，使用</span><span class="mi">1</span><span class="err">和</span><span class="mi">2</span><span class="err">结果再去查询</span>
<span class="k">SELECT</span> <span class="n">ENAME</span><span class="p">,</span><span class="n">SAL</span> <span class="k">FROM</span> <span class="n">EMP</span> <span class="k">WHERE</span> <span class="n">DEPTNO</span><span class="o">=</span><span class="p">(</span><span class="k">SELECT</span> <span class="n">DEPTNO</span> <span class="k">FROM</span> <span class="n">EMP</span> <span class="k">WHERE</span> <span class="n">ENAME</span> <span class="o">=</span><span class="s1">'SCOTT'</span><span class="p">)</span>
<span class="k">AND</span> <span class="n">SAL</span> <span class="o">&lt;</span><span class="p">(</span><span class="k">SELECT</span> <span class="n">SAL</span> <span class="k">FROM</span> <span class="n">EMP</span> <span class="k">WHERE</span> <span class="n">ENAME</span><span class="o">=</span><span class="s1">'SCOTT'</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="142-语法格式">14.2 <strong>语法格式：</strong></h2>

<p>select 字段列表   from table</p>

<p>​    where 表达式  operator  (select 字段列表  from table);</p>

<h2 id="143-特点">14.3 <strong>特点</strong></h2>

<p>子查询在主查询前执行一次</p>

<p>主查询使用子查询的结果</p>

<p>使用子查询注意事项</p>

<p>在查询是基于未知值时应考虑使用子查询</p>

<p><strong>子查询必须包含在括号内</strong></p>

<p>建议将子查询放在比较运算符的右侧，以增强可读性。</p>

<p>如果子查询返回单行结果，则为单行子查询，可以在主查询中对其使用相应的单行记录比较运算符</p>

<p>如果子查询返回多行结果，则为多行子查询，此时不允许对其使用单行记录比较运算符</p>

<h2 id="144-单行子查询">14.4 <strong>单行子查询</strong></h2>

<p>单行子查询只返回一行记录</p>

<p>对单行子查询可使用单行记录比较运算符</p>

<p>&lt; 、  &gt; 、  = 、 &gt;=、  &lt;= 、 &lt;&gt;</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">思考：查询工资最高的雇员名字和工资。</span>
<span class="mi">1</span><span class="p">,</span><span class="err">使用函数找到所有员的中的最高工资</span>
<span class="k">SELECT</span> <span class="k">MAX</span><span class="p">(</span><span class="n">SAL</span><span class="p">)</span> <span class="k">FROM</span> <span class="n">EMP</span><span class="p">;</span>
<span class="mi">2</span><span class="p">,</span><span class="err">使用</span><span class="mi">1</span><span class="err">的结果去</span><span class="n">emp</span><span class="err">表里面查询</span>
<span class="k">SELECT</span> <span class="n">ENAME</span><span class="p">,</span><span class="n">SAL</span> <span class="k">FROM</span> <span class="n">EMP</span> <span class="k">WHERE</span> <span class="n">SAL</span><span class="o">=</span><span class="p">(</span><span class="k">SELECT</span> <span class="k">MAX</span><span class="p">(</span><span class="n">SAL</span><span class="p">)</span> <span class="k">FROM</span> <span class="n">EMP</span><span class="p">)</span>
<span class="err">查询职务和</span><span class="n">SCOTT</span><span class="err">相同，比</span><span class="n">SCOTT</span><span class="err">雇佣时间早的雇员信息</span>
<span class="mi">1</span><span class="p">,</span><span class="err">查询出</span><span class="n">SCOTT</span><span class="err">的职务</span><span class="p">[</span><span class="n">job</span><span class="p">]</span>
<span class="k">SELECT</span> <span class="n">JOB</span> <span class="k">FROM</span> <span class="n">EMP</span> <span class="k">WHERE</span> <span class="n">ENAME</span><span class="o">=</span><span class="s1">'SCOTT'</span><span class="p">;</span>
<span class="mi">2</span><span class="p">,</span><span class="err">查询出</span><span class="n">SCOTT</span><span class="err">的雇佣时间</span>
<span class="k">SELECT</span> <span class="n">HIREDATE</span> <span class="k">FROM</span> <span class="n">EMP</span> <span class="k">WHERE</span> <span class="n">ENAME</span><span class="o">=</span><span class="s1">'SCOTT'</span><span class="p">;</span>
<span class="mi">3</span><span class="err">，使用</span><span class="mi">1</span><span class="err">和</span><span class="mi">2</span><span class="err">的结果再次进行查询</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">EMP</span> <span class="k">WHERE</span> <span class="n">JOB</span><span class="o">=</span><span class="p">(</span><span class="k">SELECT</span> <span class="n">JOB</span> <span class="k">FROM</span> <span class="n">EMP</span> <span class="k">WHERE</span> <span class="n">ENAME</span><span class="o">=</span><span class="s1">'SCOTT'</span><span class="p">)</span>
	<span class="k">AND</span> <span class="n">HIREDATE</span><span class="o">&lt;</span><span class="p">(</span><span class="k">SELECT</span> <span class="n">HIREDATE</span> <span class="k">FROM</span> <span class="n">EMP</span> <span class="k">WHERE</span> <span class="n">ENAME</span><span class="o">=</span><span class="s1">'SCOTT'</span><span class="p">)</span>

<span class="err">查询工资比</span><span class="n">SCOTT</span><span class="err">高或者雇佣时间比</span><span class="n">SCOTT</span><span class="err">早的雇员的编号和名字</span>
<span class="mi">1</span><span class="p">,</span><span class="err">查询出</span><span class="n">SCOTT</span><span class="err">的工资</span>
<span class="k">SELECT</span> <span class="n">SAL</span> <span class="k">FROM</span> <span class="n">EMP</span> <span class="k">WHERE</span> <span class="n">ENAME</span><span class="o">=</span><span class="s1">'SCOTT'</span><span class="p">;</span>
<span class="mi">2</span><span class="err">，查询出</span><span class="n">SCOTT</span><span class="err">的入职时间</span>
<span class="k">SELECT</span> <span class="n">HIREDATE</span> <span class="k">FROM</span> <span class="n">EMP</span> <span class="k">WHERE</span> <span class="n">ENAME</span><span class="o">=</span><span class="s1">'SCOTT'</span><span class="p">;</span>
<span class="mi">3</span><span class="p">,</span><span class="err">使用上面的结果再次查询</span>
<span class="k">SELECT</span> <span class="n">ENAME</span><span class="p">,</span><span class="n">EMPNO</span> <span class="k">FROM</span> <span class="n">EMP</span> <span class="k">WHERE</span> <span class="n">SAL</span><span class="o">&gt;</span><span class="p">(</span><span class="k">SELECT</span> <span class="n">SAL</span> <span class="k">FROM</span> <span class="n">EMP</span> <span class="k">WHERE</span> <span class="n">ENAME</span><span class="o">=</span><span class="s1">'SCOTT'</span><span class="p">)</span>
				<span class="k">OR</span> <span class="n">HIREDATE</span> <span class="o">&lt;</span><span class="p">(</span><span class="k">SELECT</span> <span class="n">HIREDATE</span> <span class="k">FROM</span> <span class="n">EMP</span> <span class="k">WHERE</span> <span class="n">ENAME</span><span class="o">=</span><span class="s1">'SCOTT'</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="145-多行子查询">14.5 <strong>多行子查询</strong></h2>

<p>多行子查询返回多行记录</p>

<p>对多行子查询只能使用多行记录比较运算符</p>

<p>ALL 和子查询返回的所有值比较</p>

<p>ANY 和子查询返回的任意一个值比较</p>

<p>IN 等于列表中的任何一个</p>

<p>```sql lite
SELECT * FROM EMP;
查询工资低于任何一个’CLERK’的工资的雇员信息。
1，查询出所有CLERK的工资
SELECT SAL FROM EMP WHERE JOB=’CLERK’
2,比较
SELECT * FROM EMP WHERE SAL&lt; ANY(SELECT SAL FROM EMP WHERE JOB=’CLERK’)</p>

<p>查询工资比所有的 ‘SALESMAN’都高的雇员的编号、名字和工资。
1,查询SALESMAN的所有工资
SELECT DISTINCT SAL FROM EMP WHERE JOB=’SALESMAN’
2,比较
SELECT EMPNO,ENAME,SAL FROM EMP WHERE SAL&gt;ALL(SELECT DISTINCT SAL FROM EMP WHERE JOB=’SALESMAN’)</p>

<p>查询部门20中职务同部门10的雇员一样的雇员信息。
1,查询部门10中的所有职务
SELECT DISTINCT JOB FROM EMP WHERE DEPTNO=10
2,查询
SELECT * FROM EMP WHERE DEPTNO=20 AND JOB IN(SELECT DISTINCT JOB FROM EMP WHERE DEPTNO=10)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
## 14.6 练习

```sql
找出部门编号为20的所有员工中收入最高的职员
1,找出20部门中收入最高的工资
SELECT MAX(SAL) FROM EMP WHERE DEPTNO=20
2,再查询20里面的员工使用1的结果去比较
SELECT * FROM EMP WHERE DEPTNO=20 AND  SAL=(SELECT MAX(SAL) FROM EMP WHERE DEPTNO=20)
查询每个部门平均薪水的等级
1，查询出部门的平均薪水
SELECT DEPTNO,AVG(SAL) AS AVGSAL FROM EMP GROUP BY DEPTNO;
2,使用1的结果和salgrade连接查询
SELECT T1.*, T2.* FROM salgrade T1 JOIN (SELECT DEPTNO,AVG(SAL) AS AVGSAL FROM EMP GROUP BY DEPTNO) T2 ON(T2.AVGSAL BETWEEN T1.LOSAL AND T1.HISAL)
</code></pre></div></div>

<h1 id="15视图">15，视图</h1>

<h2 id="151-视图的定义及作用">15.1 <strong>视图的定义及作用</strong></h2>

<h3 id="1511-定义">15.1.1 <strong>定义</strong></h3>

<p>​       视图是从若干基本表和（或）其他视图构造出来的表。</p>

<p>在创建一个视图时，只是存放的视图的定义，也即是动态检索数据的查询语句，而并不存放视图对应的数据</p>

<p>在用户使用视图时才去求相对应的数据。所以视图被称作“虚表”</p>

<h3 id="1512-作用">15.1.2 <strong>作用</strong></h3>

<p>​       可以限制对数据的访问，可以给用户授予表的特定部分的访问权限而不是整个表的访问权限。</p>

<p>可以使复杂的查询变的简单。在编写查询后，可以方便地重用它而不必知道他的基本查询细节。</p>

<p>提供了对相同数据的不同显示</p>

<h2 id="152-视图的创建和删除">15.2 视图的创建和删除</h2>

<h3 id="1521-创建或修改单表视图">15.2.1 <strong>创建或修改单表视图</strong></h3>

<pre><code class="language-mysql">CREATE OR REPLACE VIEW MYVIEW1
AS
SELECT EMPNO,ENAME,JOB,SAL FROM EMP;
</code></pre>

<h3 id="1522-视图的添加数据了解">15.2.2 视图的添加数据【了解】</h3>

<pre><code class="language-mysql">1，如果视图里面的数据都来源一同一张表，并具没有包含的数据都是可以为空的，那么我们可以使用INSERT 去向这个视图里面添加数据
2，如果视图里面的数据来源于多张表，那么不能一次性修改或添加多个基表（视图里面包含的原始表）的数据
</code></pre>

<h3 id="1523-视图的删除">15.2.3 视图的删除</h3>

<pre><code class="language-mysql">删除表  DROP TABLE IF EXISTS &lt;表名&gt;
删除数据 DELETE FROM &lt;表名&gt; WHERE 条件
删除视图 DROP VIEW &lt;视图名&gt;
</code></pre>

<h2 id="153-统计视图">15.3 统计视图</h2>

<pre><code class="language-mysql">要求，创建一个视图，并显示部门名称 部门编号，部门的平均工资 ，最高工资，最低工资，部门人数，平均工资等级
要使用的表 emp dept salgrede
CREATE OR REPLACE VIEW MYVIEW3
AS
SELECT
	T1.DNAME 部门名称,
	T2.DEPTNO 部门编号,
	T2.SALAVG 平均工资,
	T2.SALMAX 最高工资,
	T2.SALMIN 最低工资,
	T2.EMPCOUNT 员工人数,
	T3.GRADE   平均工资等级
FROM
	DEPT T1
	INNER JOIN (
	SELECT
		DEPTNO,
		AVG( SAL ) SALAVG,
		MAX( SAL ) SALMAX,
		MIN( SAL ) SALMIN,
		COUNT( 1 ) EMPCOUNT
	FROM
		EMP
	GROUP BY
		DEPTNO
	) T2
	INNER JOIN SALGRADE T3
	ON ( T1.DEPTNO = T2.DEPTNO AND T2.SALAVG BETWEEN T3.LOSAL AND T3.HISAL );

SELECT * FROM MYVIEW3;
</code></pre>

<h2 id="154-基于其它视图的视图">15.4 基于其它视图的视图</h2>

<pre><code class="language-mysql">CREATE OR REPLACE VIEW MYVIEW4
AS
SELECT 部门名称,部门编号,最高工资,最低工资  FROM MYVIEW3
</code></pre>

<h2 id="155-视图的总结">15.5 <strong>视图的总结</strong></h2>

<pre><code class="language-mysql">1.视图对应一个查询语句；视图是（从若干基本表和（或）其他视图构造出来的）表
2.视图进行查询，添加，修改，删除，其实就是对背后的表进行相应操作
3 虚表 在创建一个视图时，只是存放的视图的定义，也即是动态检索数据的查询语句，而并不存放视图对应的数据
4.视图的好处
      1.安全 可以只显示部分行部分列的数据;可以对添加的数据进行检查；可以设置为只读视图
      2.操作简单
</code></pre>

<h1 id="16-mysql存储引擎">16. MySQL存储引擎</h1>

<h2 id="161-innodb-引擎mysql55以后默认使用">16.1, <strong>InnoDB 引擎(MySQL5.5以后默认使用)</strong></h2>

<p>MySQL 5.5 及以后版本中的默认存储引擎，他的优点如下：</p>

<p>灾难恢复性好</p>

<p><strong>支持事务</strong></p>

<p><strong>使用行级锁</strong></p>

<p>支持外键关联</p>

<p>支持热备份</p>

<p>对于InnoDB引擎中的表，其数据的物理组织形式是簇表（Cluster Table），主键索引和数据是在一起的，数据按主键的顺序物理分布</p>

<p>实现了缓冲管理，不仅能缓冲索引也能缓冲数据，并且会自动创建散列索引以加快数据的获取</p>

<p>支持热备份</p>

<h2 id="162-myisam引擎">16.2 <strong>MyISAM引擎</strong></h2>

<p>特性如下：</p>

<p>不支持事务</p>

<p>使用表级锁，并发性差</p>

<p>主机宕机后，MyISAM表易损坏，灾难恢复性不佳</p>

<p>可以配合锁，实现操作系统下的复制备份、迁移</p>

<p>只缓存索引，数据的缓存是利用操作系统缓冲区来实现的。可能引发过多的系统调用且效率不佳</p>

<p>数据紧凑存储，因此可获得更小的索引和更快的全表扫描性能</p>

<h2 id="163-两种存储引擎的大致区别表现在">16.3 <strong>两种存储引擎的大致区别表现在：</strong></h2>

<p>1）InnoDB支持事务，MyISAM不支持，这一点是非常之重要。事务是一种高级的处理方式，如在一些列增删改中只要哪个出错还可以回滚还原，而MyISAM就不可以了。</p>

<p>2）MyISAM适合查询以及插入为主的应用，InnoDB适合频繁修改以及涉及到安全性较高的应用</p>

<p>3）InnoDB支持外键，MyISAM不支持</p>

<p>4）从MySQL5.5.5以后，InnoDB是默认引擎</p>

<p>5）InnoDB不支持FULLTEXT类型的索引</p>

<p>6）InnoDB中不保存表的行数，如select count(<em>) from table时，InnoDB需要扫描一遍整个表来计算有多少行，但是MyISAM只要简单的读出保存好的行数即可。注意的是，当count(</em>)语句包含where条件时MyISAM也需要扫描整个表。</p>

<p>7）对于自增长的字段，InnoDB中必须包含只有该字段的索引，但是在MyISAM表中可以和其他字段一起建立联合索引。</p>

<p>8）清空整个表时，InnoDB是一行一行的删除，效率非常慢。MyISAM则会重建表。</p>

<p>9）InnoDB支持行锁（某些情况下还是锁整表，如 update table set a=1 where user like ‘%lee%’</p>

<p>有人说MYISAM只能用于小型应用，其实这只是一种偏见。</p>

<p>如果数据量比较大，这是需要通过升级架构来解决，比如分表分库，读写分离，而不是单纯地依赖存储引擎。</p>

<p>现在一般都是选用InnoDB了，主要是MyISAM的全表锁，读写串行问题，并发效率锁表，效率低，MyISAM对于读写密集型应用一般是不会去选用的。</p>

<h2 id="164-总结">16.4 <strong>总</strong>结</h2>

<p>1.MyISAM类型不支持事务处理等高级处理，而InnoDB类型支持。</p>

<p>2.MyISAM类型的表强调的是性能，其执行速度比InnoDB类型更快，但是不提供事务支持，而InnoDB提供事务支持已经外部键等高级数据库功能。</p>

<h2 id="165相关设置">16.5，相关设置</h2>

<h3 id="1651创建表时设置">16.5.1，创建表时设置</h3>

<pre><code class="language-mysql">create table test_table(
id int(11)
)ENGINE=INNODB ,DEFAULT CHARSET = UTF8;
</code></pre>

<h3 id="1652设置默认的存储引擎">16.5.2，设置默认的存储引擎</h3>

<p>C:\ProgramData\MySQL\MySQL Server 5.7\my.ini</p>

<p><img src="/数据库/1637545745262.png" /></p>

<h1 id="17事务mysql">17.事务[mysql]</h1>

<h2 id="171-什么是事务">17.1 什么是事务</h2>

<p>完成一个事情需要的一系列步骤(操作)，这些操作要么同时成功，要么同时失败</p>

<h2 id="172-事务的基本操作">17.2 <strong>事务的基本操作</strong></h2>

<p>场景：有两个账户分别为张三和李四，他们默认都有1000块钱的余额。在这两个账户之间进行转账。</p>

<pre><code class="language-mysql">#1 创建账户表
create table tb_account(
id int(11) auto_increment,
user_name varchar(30) not null,
account_blance  int(11) not null, -- 账户余额
primary key (id)
)ENGINE=INNODB,default charset =UTF8MB4;
#2 向账户表里面添加两条测试数据
insert into tb_account(user_name,account_blance)
values('ZS',1000),('LS',1000);
# 3 执行张三向李四转账500
# ZS账户-500，LS账户+500
# 下面两个update语句要么同时执行成功要么同时执行失败
# 执行下列SQL语句会出现问题：张三的钱减少了，李四的钱没有加上。因为此时的两个update语句并没有使用事务来托管
update tb_account set account_blance=account_blance-500 where id=1;
# 银行转帐异常情况：如机机房停电
update tb_account set account_blance=account_blance+500 where id=2;


</code></pre>

<h2 id="173-事务的四大特征">17.3 <strong>事务的四大特征</strong></h2>

<p>原子性：事务每一步都是不可再分</p>

<p>一致性：张三和李四账户一共2000块钱，不管转账多少次总金额不变</p>

<p>持久性：当一个事务执行成功(完毕)，数据会持久化到磁盘的数据文件中。例如转账成功：张三余额变为500，李四余额变为1500.</p>

<p>隔离性：A事务和B事务同时操作一份数据，相互之间不影响。</p>

<h2 id="174-事务的提交方式">17.4 <strong>事务的提交方式</strong></h2>

<p>1 自动提交，MySQL默认为自动提交。</p>

<p>不需要写commit;就会自动将DML语句持久化提交</p>

<p>2 手动提交，Oracle默认手动提交。</p>

<p>如何在MySQL中查看提交方式：</p>

<pre><code class="language-mysql">-- 查询结果为1表示自动提交，0表示手动提交
select @@autocommit;
-- 修改提交方式（自动提交修改为手动提交）
set @@autocommit = 0 ;
</code></pre>

<h2 id="175-事务的基本操作">17.5 <strong>事务的基本操作</strong></h2>

<p>1 开启事务</p>

<blockquote>
  <p>start transaction;</p>
</blockquote>

<p>2 提交事务</p>

<blockquote>
  <p>commit;</p>
</blockquote>

<p>3 回滚事务</p>

<blockquote>
  <p>rollback;</p>
</blockquote>

<p>注意：一旦使用start transaction;开启事务那么自动提交将失效</p>

<p>如果所有操作都正常执行使用commit;提交事务</p>

<p>当发生异常情况回滚事务，数据(此时为tb_account表)通常回滚到开启事务之前的状态</p>

<h2 id="176-转账的操作">17.6 转账的操作</h2>

<pre><code class="language-mysql">-- 1 开启事务
start transaction;
-- 2 执行SQL语句
update tb_account set account_blance=account_blance-500 where id=1;
 手机转账异常情况：转账过程中手机没电了
update tb_account set account_blance=account_blance+500 where id=2;
-- 3 如果SQL语句全部执行成功就提交事务，如果其中任何一步执行失败，立刻回滚事务
-- 此时第一个update执行成功，第二个update语句执行失败了,并没有提交事务，查询结果如下：
select * from tb_account;
/*
+----+-----------+----------------+
| id | user_name | account_blance |
+----+-----------+----------------+
|  1 | ZS        |            500 |
|  2 | LS        |           1000 |
+----+-----------+----------------+
*/
-- 问题：张三账户的余额减少了，李账户余额没有增加。这就是脏数据
-- 此时需要将脏数据回滚到开启事务之前
rollback;
-- 回滚完毕再次查询
select * from tb_account;
-- 此时事务回滚到开启之前的状态
/*
+----+-----------+----------------+
| id | user_name | account_blance |
+----+-----------+----------------+
|  1 | ZS        |           1000 |
|  2 | LS        |           1000 |
+----+-----------+----------------+
*/
-- 一个事务一旦开启了，在没有执行commit或者rollback之前事务不会结束
-- 相关面试题：工作中有没有用到事务？请解释事务的概念？不使用事务会发生什么问题？使用事务能够解决什么问题？解释事务的四大特征[隔离级别]？
</code></pre>

<h2 id="177-事务隔离级别">17.7 <strong>事务隔离级别</strong></h2>

<h3 id="1771-iso定义的四大隔离级别">17.7.1 <strong>ISO定义的四大隔离级别</strong></h3>

<table>
  <thead>
    <tr>
      <th>事务隔离级别</th>
      <th>脏读</th>
      <th>不可重复读</th>
      <th>幻读</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1读未提交（read-uncommitted）</td>
      <td>是</td>
      <td>是</td>
      <td>是</td>
    </tr>
    <tr>
      <td>2读已提交（read-committed）</td>
      <td>否</td>
      <td>是</td>
      <td>是</td>
    </tr>
    <tr>
      <td>3可重复读（repeatable-read）</td>
      <td>否</td>
      <td>否</td>
      <td>是</td>
    </tr>
    <tr>
      <td>4串行化（serializable）</td>
      <td>否</td>
      <td>否</td>
      <td>否</td>
    </tr>
  </tbody>
</table>

<p>查询隔离级别select @@tx_isolation</p>

<p><img src="/数据库/wps4EDA.tmp.jpg" /></p>

<p>隔离级别1最低，4最高 。隔离级别越高就越安全，同时内存资源消耗也越大。隔离级别越高效率越低下。</p>

<p>工作中：1和4都不用，只会在2和3之间切换</p>

<p><strong>MySQL默认的事务隔离级别为3，Oracle默认隔离界别默认为2</strong></p>

<h3 id="1772-并发下的脏读不可重复读幻读的问题">17.7.2 <strong>并发下的脏读，不可重复读，幻读的问题</strong></h3>

<p>问题：不使用事务隔离级别会引发啥问题？使用事务隔离级别能够解决什么问题</p>

<h4 id="17721-什么是脏读">17.7.2.1 什么是脏读</h4>

<p><strong>一个事务(A</strong>)读取到另一个事务(B)没有提交的数据（破坏了隔离性）</p>

<p>例如：事务A开启事务做转账，DML语句执行成功但是没有commit；事务B在另一个窗口开启了，执行Select语句读取tb_account数据，读取到的结果是事务A没有提交的数据。</p>

<h4 id="1772-不可重复读问题">17.7.2. 不可重复读问题</h4>

<p><strong>同一个事务中多次读取到的数据不一致(破坏了一致性，update和delete)</strong></p>

<p>例如：事务A开启事务做转账，DML语句执行成功但是没有commit；；事务B在另一个窗口开启了，执行Select语句读取tb_account数据，读取的结果正确（1000,1000）.</p>

<p>事务A里面提交了事务。然后事务B再次做Select操作查询结果也正确(500,1500)</p>

<p>问题：事务B在一次事务中对tb_account表做了两次select操作，两次操作查询的结果不一致。</p>

<h4 id="17723幻读问题">17.7.2.3幻读问题</h4>

<p><strong>事务A插入一条数据，能够使用select获取结果，此时事务B几乎同时插入了一条或者大量数据，此时事务A看不到事务B的更新</strong>（破坏了一致性，insert）。</p>

<h3 id="1773-事务隔离级别的设置查询">17.7.3 事务隔离级别的设置查询</h3>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">set</span> <span class="k">session</span> <span class="n">transaction</span> <span class="k">isolation</span> <span class="k">level</span>  <span class="k">READ</span> <span class="k">UNCOMMITTED</span><span class="p">;</span>  <span class="o">#</span><span class="err">读未提交</span>
<span class="k">set</span> <span class="k">session</span> <span class="n">transaction</span> <span class="k">isolation</span> <span class="k">level</span>  <span class="k">READ</span> <span class="k">COMMITTED</span><span class="p">;</span>    <span class="o">#</span><span class="err">读已提交</span>
<span class="k">set</span> <span class="k">session</span> <span class="n">transaction</span> <span class="k">isolation</span> <span class="k">level</span>  <span class="k">REPEATABLE</span><span class="o">-</span><span class="k">READ</span><span class="p">;</span>   <span class="o">#</span><span class="err">可重复读</span>
<span class="k">set</span> <span class="k">session</span> <span class="n">transaction</span> <span class="k">isolation</span> <span class="k">level</span>  <span class="k">serializable</span><span class="p">;</span>   <span class="o">#</span><span class="err">串型化</span>

<span class="k">select</span> <span class="o">@@</span><span class="n">tx_isolation</span>  <span class="o">#</span><span class="err">查询</span>
</code></pre></div></div>

<h3 id="1774read-uncommitted脏读测试">17.7.4,read uncommitted脏读测试</h3>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">设置隔离级别为读未提交</span>
<span class="k">set</span> <span class="k">session</span> <span class="n">transaction</span> <span class="k">isolation</span> <span class="k">level</span>  <span class="k">READ</span> <span class="k">UNCOMMITTED</span><span class="p">;</span>
</code></pre></div></div>

<p><img src="/数据库/1637550774244.png" /></p>

<h3 id="1775read-committed解决脏读">17.7.5,read committed解决脏读</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>如何解决脏读问题？修改事务隔离级别：读已提交
set session transaction isolation level read committed;
</code></pre></div></div>

<p><img src="/数据库/1637550994039.png" /></p>

<h3 id="1776repeatable-read解决不可重复读问题">17.7.6,repeatable read解决不可重复读问题</h3>

<pre><code class="language-mysql">set session transaction isolation level repeatable read;
数据都改成1000再按下图进行测试
</code></pre>

<p><img src="/数据库/1637551222066.png" /></p>

<h3 id="1777-串行化serializable测试">17.7.7 <strong>串行化serializable</strong>测试</h3>

<p>能够解决所有的问题，但是效率低下，它类似Java的synchronized</p>

<p>Java使用synchronized用来锁对象。MySQL使用serializable锁表，事务A开启事务，做了DML操作，但是没有提交。此时事务B开启事务，执行select操作，没有查询到数据，因为此时tb_account表被事务A占用了(锁住了)。</p>

<pre><code class="language-mysql">set session transaction isolation level serializable;

数据还原
</code></pre>

<p><img src="/数据库/1637551581380.png" /></p>

<h1 id="18-索引">18， 索引</h1>

<p>面试的问题：</p>

<p>1，做过SQL调优吗？</p>

<p>2，为什么索引能加快查询速度，那么是不是索引越多越好</p>

<p>3，除了索引优化，还有没有其它的数据库化方案</p>

<h2 id="181什么是索引">18.1，什么是索引</h2>

<pre><code class="language-mysql">1，大大提高MySQL的查询速度，只能提高查询速度。
2，索引分单列索引和组合索引。单列索引，即一个索引只包含单个列，一个表可以有多个单列索引，但这不是组合索引。组合索引，即一个索引包含多个列。
3，创建索引时，你需要确保该索引是应用在 SQL 查询语句的条件(一般作为 WHERE 子句的条件)
4，建立索引会占用磁盘空间的索引文件
</code></pre>

<h2 id="182准备工作创建表">18.2，准备工作创建表</h2>

<pre><code class="language-mysql">DROP TABLE IF EXISTS person;
CREATE TABLE person  (
  PID int(11) NOT NULL AUTO_INCREMENT COMMENT '编号',
  PNAME varchar(50)  NOT NULL COMMENT '姓名',
  PSEX varchar(10) NULL DEFAULT NULL COMMENT '性别',
	PAGE	int(11)  NOT NULL COMMENT '年龄',
  SAL decimal(7, 2) NULL DEFAULT NULL COMMENT '工资',
  PRIMARY KEY (PID)
) ENGINE = InnoDB AUTO_INCREMENT = 1 CHARACTER SET = utf8mb4 COMMENT = '人员表';
</code></pre>

<h2 id="183-索引分类">18.3 索引分类</h2>

<h3 id="1831-普通索引">18.3.1 普通索引</h3>

<p>【创建语法】</p>

<pre><code class="language-mysql">CREATE INDEX &lt;索引名&gt; ON &lt;表名&gt;(字段)
</code></pre>

<p>【删除语法】</p>

<pre><code class="language-mysql">ALTER TABLE &lt;表名称&gt; DROP INDEX &lt;索引名称&gt;
</code></pre>

<h4 id="18311-为person表的pname列建立普通索引">18.3.1.1 为person表的pname列建立普通索引</h4>

<pre><code class="language-mysql">CREATE INDEX INDEX_PERSON_PNAME ON PERSON(PNAME)
</code></pre>

<p>查询测试</p>

<p><img src="/数据库/1637562496617.png" /></p>

<p>看到了ALL就说明这个查询没有走索引</p>

<p>【创建索引之后再测试】</p>

<p><img src="/数据库/1637562604858.png" /></p>

<h4 id="18312-一个表的主键生成之后会默认有一个主键索引">18.3.1.2 一个表的主键生成之后会默认有一个主键索引</h4>

<p><img src="/数据库/1637562726647.png" /></p>

<h4 id="18313-where-pname-like-模糊查询用到索引没有">18.3.1.3 where pname like 模糊查询用到索引没有</h4>

<pre><code class="language-mysql">EXPLAIN SELECT * FROM PERSON WHERE PNAME LIKE 'HELLO' #走索引
EXPLAIN SELECT * FROM PERSON WHERE PNAME LIKE 'HELLO%'  #走索引
EXPLAIN SELECT * FROM PERSON WHERE PNAME LIKE '%HELLO%' #不走索引
</code></pre>

<h3 id="1832-普通索引的压力测试">18.3.2 普通索引的压力测试</h3>

<p>向person表中插入500W条数据,为pname创建一个索引，观察创建索引之前执行耗时是多长时间，创建索引之后耗时多长时间。</p>

<h4 id="删除之前索引">【删除之前索引】</h4>

<pre><code class="language-mysql">ALTER TABLE PERSON DROP INDEX INDEX_PERSON_PNAME;
</code></pre>

<h4 id="数据查看">【数据查看】</h4>

<p><img src="/数据库/1637563145011.png" /></p>

<h4 id="创建一个生成随机字符串的函数">【创建一个生成随机字符串的函数】</h4>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">FUNCTION</span> <span class="n">RAND_STRING</span><span class="p">(</span><span class="n">N</span> <span class="nb">INT</span><span class="p">)</span> <span class="k">RETURNS</span> <span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">255</span><span class="p">)</span>
<span class="k">BEGIN</span>
	<span class="k">DECLARE</span> <span class="n">CHARS_STR</span> <span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">255</span><span class="p">)</span> <span class="k">DEFAULT</span> <span class="s1">'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890'</span><span class="p">;</span>
	<span class="k">DECLARE</span> <span class="n">RETURN_STR</span> <span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">255</span><span class="p">)</span> <span class="k">DEFAULT</span> <span class="s1">''</span><span class="p">;</span>
	<span class="k">DECLARE</span> <span class="n">I</span> <span class="nb">INT</span> <span class="k">DEFAULT</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">WHILE</span> <span class="n">I</span><span class="o">&lt;</span><span class="n">N</span> <span class="k">DO</span>
		<span class="k">SET</span> <span class="n">RETURN_STR</span><span class="o">=</span><span class="n">CONCAT</span><span class="p">(</span><span class="n">RETURN_STR</span><span class="p">,</span><span class="k">SUBSTRING</span><span class="p">(</span><span class="n">CHARS_STR</span><span class="p">,</span><span class="n">FLOOR</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">RAND</span><span class="p">()</span><span class="o">*</span><span class="mi">62</span><span class="p">),</span><span class="mi">1</span><span class="p">));</span>
		<span class="k">SET</span> <span class="n">I</span><span class="o">=</span><span class="n">I</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">END</span> <span class="n">WHILE</span><span class="p">;</span>
	<span class="k">RETURN</span> <span class="n">RETURN_STR</span><span class="p">;</span>
<span class="k">END</span><span class="p">;</span>
</code></pre></div></div>

<h4 id="创建一个存储过程生成数据">【创建一个存储过程生成数据】</h4>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">create</span> <span class="k">procedure</span> <span class="n">insert_person</span><span class="p">(</span><span class="k">in</span> <span class="n">max_num</span> <span class="nb">int</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
<span class="k">begin</span>
	<span class="k">declare</span> <span class="n">i</span> <span class="nb">int</span> <span class="k">default</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">set</span> <span class="n">autocommit</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">-- 把autocommit设置成0，这样可以只提交一次，否则。。。。。</span>
	<span class="n">repeat</span>
	<span class="k">set</span> <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">insert</span> <span class="k">into</span> <span class="n">person</span> <span class="p">(</span><span class="n">PID</span><span class="p">,</span><span class="n">PNAME</span><span class="p">,</span><span class="n">PSEX</span><span class="p">,</span><span class="n">PAGE</span><span class="p">,</span><span class="n">SAL</span><span class="p">)</span> <span class="k">values</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">RAND_STRING</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span><span class="n">IF</span><span class="p">(</span><span class="n">RAND</span><span class="p">()</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">,</span><span class="s1">'男'</span><span class="p">,</span><span class="s1">'女'</span><span class="p">),</span><span class="n">FLOOR</span><span class="p">((</span><span class="n">RAND</span><span class="p">()</span><span class="o">*</span><span class="mi">100</span><span class="p">)</span><span class="o">+</span><span class="mi">10</span><span class="p">),</span><span class="n">FLOOR</span><span class="p">((</span><span class="n">RAND</span><span class="p">()</span><span class="o">*</span><span class="mi">19000</span><span class="p">)</span><span class="o">+</span><span class="mi">1000</span><span class="p">));</span>
	<span class="k">until</span> <span class="n">i</span> <span class="o">=</span> <span class="n">max_num</span>
	<span class="k">end</span> <span class="n">repeat</span><span class="p">;</span>
	<span class="k">commit</span><span class="p">;</span>
<span class="k">end</span><span class="p">;</span>
</code></pre></div></div>

<h4 id="再次查看数据文件">【再次查看数据文件】</h4>

<p><img src="/数据库/1637565474636.png" /></p>

<h4 id="给pname创建索引">【给PNAME创建索引】</h4>

<pre><code class="language-mysql">CREATE INDEX INDEX_PERSON_PNAME ON PERSON(PNAME)
</code></pre>

<p><img src="/数据库/1637565515616.png" /></p>

<p><img src="/数据库/1637565560952.png" /></p>

<h4 id="查询的说明">【查询的说明】</h4>

<p>【有索引】</p>

<p><img src="/数据库/1637565690233.png" /></p>

<p>【没有索引】</p>

<p><img src="/数据库/1637565663421.png" /></p>

<p>【四问索引】</p>

<pre><code class="language-mysql">问题1：为person表的pname创建索引消耗了9.472秒，为什么耗时这么长？
在person.ibd数据文件中创建了一个“目录”，目录的结构是一个B+Tree，类似Java的TreeMap，表的数据越多，索引结构越大，创建时间越长。
问题2：没有创建索引执行WHERE PNAME耗时3.892秒，创建索引执行耗时0.03秒，为什么这么快？
没有创建索引，进行全文检索(从person.ibd数据文件中检索所有的输入，然后在判断是否满足where条件)，创建索引不进行全文检索，直接查询索引
问题3：创建索引之前数据文件person.ibd大小229376，创建索引之后大小319488，为什么会有这么大的变化？
创建索引就相当于创建目录，表中的数据越大，数据文件就越多。
问题4：INDEX_PERSON_PNAME索引的内部结构是啥？
类似TreeMap的B+Tree
</code></pre>

<p><img src="/数据库/wpsCCCF.tmp.jpg" /></p>

<h3 id="1832-组合索引的创建">18.3.2 组合索引的创建</h3>

<pre><code class="language-mysql">为多个列创建复合索引
CREATE INDEX INDEX_PERSON_AGE_SEX ON PERSON(PAGE,PSEX);
</code></pre>

<pre><code class="language-mysql">CREATE INDEX INDEX_PERSON_AGE_SEX ON PERSON(PAGE,PSEX);
EXPLAIN SELECT * FROM PERSON WHERE PAGE=22 AND PSEX='男'  #走索引

EXPLAIN SELECT * FROM PERSON WHERE PSEX='男' AND PAGE=22 #走索引

EXPLAIN SELECT * FROM PERSON WHERE PAGE=22  #走索引

EXPLAIN SELECT * FROM PERSON WHERE PSEX='男'  #不走索引
</code></pre>

<p>总结：</p>

<p>组合索引由多列构成，如果在索引里面的第一列在查询条件里面没有出现就不会走索引</p>

<h3 id="1834-person表的psex列只有2个有效值为该列建立索引会提高查询效率吗">18.3.4 PERSON表的PSEX列只有2个有效值，为该列建立索引会提高查询效率吗</h3>

<pre><code class="language-mysql">-- 为性别列创建索引【只有两个值 男  女】
SELECT * FROM PERSON WHERE PSEX='男'  #2.527s  [无索引的时长]
CREATE INDEX INDEX_CUSTOMER_SEX ON PERSON(PSEX);
EXPLAIN SELECT * FROM PERSON WHERE PSEX='男'  #15.307s  [索引的时长]
</code></pre>

<p>总结：如果数据库字段里面的值的选项少，不能创建索引</p>

<h3 id="1835唯一索引的创建">18.3.5唯一索引的创建</h3>

<pre><code class="language-mysql">1，在创建表时指定字段唯 一，那么系统会默认在该字段上加一个唯一索引来提高查询速度
2，CREATE UNIQUE INDEX 索引名称 ON 表名称(列名称);来创建唯一索引
</code></pre>

<h2 id="面试题">【面试题】</h2>

<p>1，做过SQL调优吗？</p>

<pre><code class="language-mysql">绕开这个问题，引入 索引优化，引入数据库的分库分等优化
</code></pre>

<p>2，为什么索引能加快查询速度，</p>

<pre><code class="language-mysql">索引相当于在数据库里面为我们每一条数据创建一数据库录，查询时不是直接查询数据，而是先找到的目录
</code></pre>

<p>3，那么是不是索引越多越好</p>

<pre><code class="language-mysql">不是，因为如果是添加和修改和删除会重新调整索引里面的数据【调整过程很耗时】
有索引的情况
	会降低添加  删除速度
如果修改的字段上没有索引，那对速度没有影响
</code></pre>

<p>4，除了索引优化，还有没有其它的数据库化方案</p>

<pre><code class="language-mysql">1，对于常用查询条件创建索引
2，开启SQL的慢查询日志
	|--MYSQL会记录所有的查询执行的时间，开启慢查询设置超过2秒的查询就加入慢查询列表，它会把所有超过2秒的查询语做记录，我们程序员过以通过慢查询日志找到具体是哪一个SQL执行的比较，进而针对性的去优化SQL
3，数据量大了怎么办
	一般一个表里面的数据超过1000W条数据，就要着手考虑分库分表
		|--分库分表的方案
			MYSQL 自带了主从结构 和读写分离 [主数据和从数据]
		|--配合mycat 这种数据库中间件进行分库分表的配置
			|--一个表里面的数据量大，那么我们把这个表分成多个表，把数据分开存储

</code></pre>

<h1 id="19数据库设计原则">19，数据库设计原则</h1>

<h2 id="191-数据库设置软件">19.1 数据库设置软件</h2>

<p>PowerDesiger</p>

<p><img src="/数据库/1637569430047.png" /></p>

<p><img src="/数据库/1637569458826.png" /></p>

<p><img src="/数据库/1637569512896.png" /></p>

<h2 id="192-引入三大范式">19.2 引入三大范式</h2>

<p>目地：保证数据库设计的合理性</p>

<p>用范式来规范我们数据库的设计</p>

<h3 id="1921-第一范式">19.2.1 <strong>第一范式</strong></h3>

<p>数据库表每一列都是不可分割的基本数据项，同一列中不能有多个值</p>

<p>简单说就是要确保每列保持原子性</p>

<pre><code class="language-mysql">设计表
第一版【编号 姓名  性别  年龄   地址】
ID   NAME   SEX  AGE      ADDRESS
1    张三    男    18      湖北省武汉市东湖新技术开发区
第二版【编号 姓名  性别  年龄   省  市   区/镇  街道/村 】


</code></pre>

<h3 id="1922-第二范式多对多">19.2.2 <strong>第二范式</strong>【多对多】</h3>

<p>【要求】</p>

<p>第二范式需要确保数据库表中的每一列都和主键相关，而不能只与主键的某一部分相关（主要针对联合主键而言）。</p>

<p>即在一个数据库表中只能保存一种数据，不可以把多种数据保存在同一张数据库表中。</p>

<h3 id="1923-第三范式一对多和多对一">19.2.3 <strong>第三范式</strong>【一对多和多对一】</h3>

<p>【要求】</p>

<p>确保数据表中的每一列数据都和主键直接相关，而不能间接相关</p>

<p>属性不依赖于其他非主属性。</p>

<p><img src="/数据库/wps21E5.tmp.jpg" /></p>

<p>分析以上的表，发现有问题存在  班级名称和班级信息出现了数据冗余</p>

<p>如何解决</p>

<p>学生表</p>

<p>班级表</p>

<p>1，学生表</p>

<p><img src="/数据库/wps38D9.tmp.jpg" /></p>

<p>2，班级表</p>

<p><img src="/数据库/wps38DA.tmp.jpg" /></p>

<h2 id="193--范式的优缺点">19.3  <strong>范式的优缺点</strong></h2>

<h3 id="1931-优点">19.3.1 <strong>优点</strong></h3>

<p>结构合理</p>

<p>冗余较小</p>

<p>尽量避免插入删除修改异常</p>

<h3 id="1932-缺点">19.3.2 <strong>缺点</strong></h3>

<p>性能降低</p>

<p>多表查询比单表查询速度慢</p>

<h3 id="1933-数据库的设计应该根据当前情况和需求做出灵活的处理">19.3.3 <strong>数据库的设计应该根据当前情况和需求做出灵活的处理。</strong></h3>

<p>在实际设计中，要整体遵循范式理论。</p>

<p>如果在某些特定的情况下还死死遵循范式也是不可取的，因为可能降低数据库的效率，此时可以适当增加冗余而提高性能。</p>

<h3 id="1931-数据库的设计应该根据当前情况和需求做出灵活的处理">19.3.1 <strong>数据库的设计应该根据当前情况和需求做出灵活的处理。</strong></h3>

<p>在实际设计中，要整体遵循范式理论。</p>

<p>如果在某些特定的情况下还死死遵循范式也是不可取的，因为可能降低数据库的效率，此时可以适当增加冗余而提高性能。</p>

<h3 id="1932-示例">19.3.2 <strong>示例：</strong></h3>

<p>比如经常购物车条目的中除了条目编号，商品编号，商品数量外，可以增加经常使用的商品名称，商品价格等</p>

<p>商品表</p>

<p><img src="/数据库/wps8074.tmp.jpg" /></p>

<p>订单明细表</p>

<p><img src="/数据库/wps8085.tmp.jpg" /></p>

<h1 id="1-设计一个商品入库审批的数据库">1. <strong>设计一个商品入库审批的数据库</strong></h1>

<p>对象 商品</p>

<p>仓库</p>

<p>入库订单</p>

<p>订单详情</p>

<p><img src="/数据库/wpsBA56.tmp.jpg" /></p>

<h1 id="1-设计一个商品购物车的数据库作业">1. 设计一个商品购物车的数据库【作业】</h1>

<p>商品表</p>

<p>商家表</p>

<p>用户表</p>

<p>订单表</p>

<p>订单明细</p>]]></content><author><name>qihuan</name></author><summary type="html"><![CDATA[1，数据库的相关概念 1.1 数据 1，定义：描述事务的符号 2，表达形式：多种表现形式：文本，图形，音频，视频 1.2 数据库（Database, DB） 1，粮库 车库 2，存放数据的仓库 存放在计算机中，按照一定格式存放 可为用户共享 1.3 数据库管理系统（Database Management System, DBMS） 1，如何科学的组织和存储数据，如何高效的获取和维护数据，靠数据库管理系统完成 2，Oracle MySQL SQL Server DB2 FoxPro，Access sqlite 1.4 数据库应用程序（DBAS） 1，在数据库管理系统基础上，使用数据库管理系统的语法，开发的直接面对最终用户的应用程序 2，学生管理系统、人事管理系统、图书管理系统 1.5 数据库管理员（Database Administrator, DBA） 1，数据库管理系统的操作者 1.6 最终用户 1，数据库应用程序的使用者 1.7 数据库系统 1，数据库+数据库管理系统+数据库应用程序+最终用户 ![img](数据库/wpsD145.tmp.png”/&gt; 1.8 数据库的发展阶段 1，网状数据库 2，层次数据库【tree】 3，关系数据库 采用关系[二维表]结构存储与管理数据 采用结构化查询语言(sql)作为客户端数据库服务器间沟通的桥梁 目前主流的数据库技术 4，对象数据库 1.9 NOSQL数据库 1，Not only sql数据库 泛指非关系数据库。如MongoDB,Redis 2，关系数据库在超大规模和高并发的web2.0纯属动态网站已经显示力不从心，暴露了很多难以克服的问题。Nosql数据库的产生就是为了解决大无框数据集合多重数据种类带来的挑战，尤其是大数据应用难题 1.10 市场上流行的关系型数据库 数据库 厂商 Oracle 甲骨文公司 MySQL MySQL甲骨文 SQLServer Microsoft DB2 IBM Sqlite RichardHipp 2 ，数据库的相关操作 2.1 启动|停止 【方式1】 cmd– net start stop mysql 以上的错的原因是因为没有管理员权限 【方式2】 win+R – control–打开控制面板 2.2 使用root账户登陆 mysql -uroot -p123456 root是默认的用户名—超级管理员 123456是之前我们安装的时候设置的默认密码 2.3 显示所有数据库 show databases; 2.4 默认的几个数据库说明 2.4.1 information_schema information_schema数据库是MySQL自带的，它提供了访问数据库元数据的方式。什么是元数据呢？元数据是关于数据的数据，如数据库名或表名，列的数据类型，或访问权限等。有些时候用于表述该信息的其他术语包括“数据词典”和“系统目录”。 在MySQL中，把 information_schema 看作是一个数据库，确切说是信息数据库。其中保存着关于MySQL服务器所维护的所有其他数据库的信息。如数据库名，数据库的表，表栏的数据类型与访问权 限等。在INFORMATION_SCHEMA中，有数个只读表。它们实际上是视图，而不是基本表，因此，你将无法看到与之相关的任何文件 2.4.2 mysql 这个是mysql的核心数据库，主要负责存储数据库的用户、权限设置、关键字等mysql自己需要使用的控制和管理信息。不可以删除，如果对mysql不是很了解，也不要轻易修改这个数据库里面的表信息。 2.4.3 performance_schema mysql 5.5 版本 新增了一个性能优化的引擎： PERFORMANCE_SCHEMA这个功能默认是关闭的： 需要设置参数： performance_schema 才可以启动该功能，这个参数是静态参数，只能写在 my.cnf 中 不能动态修改。 windows里面叫 my.ini文件 C:\ProgramData\MySQL\MySQL Server 5.7 【默认在这个目录】 linux里面叫my.cnf文件 2.4.4 sys 通过这个库可以快速的了解系统的元数据信息 这个库确实可以方便DBA发现数据库的很多信息，解决性能瓶颈都提供了巨大帮助 2.4.5 重要说明 以上的4个默认库。都不要删除，只有自己创建的库可以删除 2.5 使用某一个数据库 -- 语法 -- use &lt;数据库名称&gt;; -- 例如：使用mysql数据库 use mysql; 2.6 修改密码 -- 1使用mysql数据库 use mysql; -- 2修改密码命令(将root用户的密码修改为123456) update mysql.user set authentication_string=PASSWORD('123456') where user='root; -- 3刷新 flush privileges; 2.7 创建用户 2.7.1 命令 CREATE USER 'username'@'host' IDENTIFIED BY 'password'; 2.7.2 说明 username：你将创建的用户名 host：指定该用户在哪个主机上可以登陆，如果是本地用户可用localhost，如果想让该用户可以从任意远程主机登陆，可以使用通配符% password：该用户的登陆密码，密码可以为空，如果为空则该用户可以不需要密码登陆服务器 2.7.3 例子 CREATE USER 'dog'@'localhost' IDENTIFIED BY '123456'; CREATE USER 'pig'@'192.168.1.101' IDENDIFIED BY '123456'; CREATE USER 'pig'@'%' IDENTIFIED BY '123456'; CREATE USER 'pig'@'%' IDENTIFIED BY ''; CREATE USER 'pig'@'%'; 2.8 给用户授权 2.8.1 命令 GRANT privileges ON databasename.tablename TO 'username'@'host' 2.8.2 说明 privileges：用户的操作权限，如SELECT，INSERT，UPDATE等，如果要授予所的权限则使用ALL databasename：数据库名 tablename：表名，如果要授予该用户对所有数据库和表的相应操作权限则可用*表示，如*.* 2.8.3 例子 GRANT SELECT ON wh2105.user TO 'dog'@'localhost'; |--给host=localhost这个用户对wh2105数据库的user表的查询权限 GRANT ALL ON *.* TO 'dog'@'%'; |--给host=%的dog用户 对所有数据库的所有表表的所有权限 GRANT ALL ON wh2105.* TO 'dog'@'%'; |--给host=%的dog用户 对wh2105数据库的所有表的所有权限 2.8.4 注意 用以上命令授权的用户不能给其它用户授权，如果想让该用户可以授权，用以下命令: GRANT privileges ON databasename.tablename TO 'username'@'host' WITH GRANT OPTION; 2.8.5 作用 多公司协同开发的，如A公司需要B公司的数据，那么A公司可以创建一个用户给B公司，并且去设置相关权限 2.9 创建一个数据库 -- 创建数据库有两种方式： -- 第一种 语法如下 -- 注意：&lt;&gt;里面的内容都是可变的 -- create database &lt;数据库名称&gt;; -- 例如 create database whqihuan; -- 第二种 语法如下 -- if not exists 创建之前会做check操作，如果数据库名称在MySQL数据库管理系统中不存在才创建 -- charset default 为数据库指定默认编码 -- create database if not exists &lt;数据库名称&gt; default charset &lt;数据库字符集编码&gt;; -- 例如： create database if not exists whqihuan default charset UTF8; create database if not exists whqihuan default charset UTF8MB4; -- UTF8和UTF8MB4区别？ -- 绝大多数情况下使用UTF8编码的字符集一个汉字占据3个字符，但是有极少数情况下一个汉字占据4个字符 -- 占据4个字符的汉字不能使用UTF8存储，必须使用UTF8MB4存储 -- UTF8MB4字符集编码表示一个汉字最多占据4个字符 M Most B Byte 可以存放微信的表情 -- 注意：创建数据库指定的字符集编码必须跟MySQL数据库里面的my.ini字符集编码保持一致 2.10 删除一个数据库 -- 第一种方式 语法： -- drop database &lt;数据库名称&gt;; -- 例如： drop database whqihuan; -- 第二种方式 语法： -- 删除之前先判断 存在才删除 -- drop database if exists &lt;数据库名称&gt;; -- 例如： drop database if exists whqihuan; 2.11 修改数据库默认编码 C:\ProgramData\MySQL\MySQL Server 5.7 重启mysql 3. 什么是SQL SQL是一个面向过程的结构化查询语言，全称Struct Query Language 。我们对MySQL做的任何操作(命令)都建立在结构化查询语言中。 SQL由以下四部分组成：DDL、DML、DQL、TCL ,DCL 3.1DDL 数据定义语言 全称Data Definition Language，主要用于创建和删除结构。 Ø 1)创建结构相关操作：表、视图、索引、数据 Ø 2)删除结构相关操作：表、视图、索引、数据 Ø 3)改变结构相关操作：表、视图、索引、数据 3.2 DML 数据操纵语言 DML对表和视图进行插入、删除、更新相关操作，全称Data Manipulation Language。 插入数据关键字：insert 删除数据关键字：delete 修改数据关键字：update 3.3 DQL 数据查询语言 对表和视图进行操作，全称： Data Query Language 3.4 DQL关键字 select TCL全称Transaction Control Language，使用事务管理DML操作。 Ø 提交事务关键字 commit; Ø 回滚事务关键字 rollback; Ø 开启事务关键字 start transaction; 3.5 DCL 数据控制语言 Data Control Language 主控制权限 4. MySQL数据类型 4.1 整数类型—java[Integer Long] 数据类型 大小 描述 tinyint 8bit 范围(-128~127) smallint 16bit 范围(-32768~32767) mediumint 24bit 范围(-8388608~8388607) int 32bit 范围(-2147483648~2147483647) bigint 64bit 范围(+-9.22*10的18次方) 4.2 小数类型—java[float double] float(m,d) 32bit 单精度浮点型，m总个数，d小数位 double(m,d) 64bit 双精度浮点型，m总个数，d小数位 4.3 定点数—-java[BigDecimal] 浮点型在数据库中存放的是近似值，而定点类型在数据库中存放的是精确值。 decimal(m,d) 参数m是总个数，d是小数位。 4.4 字符串 —java[String] MySQL数据类型 含义 char(n) 固定长度，最多255个字符，索引效率级高，必须在括号里定义长度，可以有默认值 varchar(n) 可变长度，最多65535个字符 tinytext 可变长度，最多255个字符 text 可变长度，最多65535个字符 mediumtext 可变长度，最多2的24次方-1个字符 longtext 可变长度，最多2的32次方-1个字符 json mysql5.7新增加的数据类型，用来存放json数据 char：存储定长数据很方便，CHAR字段上的索引效率级高，必须在括号里定义长度，可以有默认值，比如定义char(10)，那么不论你存储的数据是否达到了10个字节，都要占去10个字节的空间（自动用空格填充），且在检索的时候后面的空格会隐藏掉，所以检索出来的数据需要记得用什么trim之类的函数去过滤空格。 varchar：存储变长数据，但存储效率没有CHAR高，必须在括号里定义长度，可以有默认值。保存数据的时候，不进行空格自动填充，而且如果数据存在空格时，当值保存和检索时尾部的空格仍会保留。另外，varchar类型的实际长度是它的值的实际长度+1，这一个字节用于保存实际使用了多大的长度。 text：存储可变长度的非Unicode数据，最大长度为2^31-1个字符。text列不能有默认值，存储或检索过程中，不存在大小写转换，后面如果指定长度，不会报错误，但是这个长度是不起作用的，意思就是你插入数据的时候，超过你指定的长度还是可以正常插入。text默认不走索引 1、经常变化的字段用varchar； 2、知道固定长度的用char； 3、超过255字节的只能用varchar或者text； 4、能用varchar的地方不用text； 5、能够用数字类型的字段尽量选择数字类型而不用字符串类型，这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连接回逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了； 6、同一张表出现多个大字段，能合并时尽量合并，不能合并时考虑分表 4.5 日期时间类型[java Date LocalDate Timestemp] date 日期 ‘2021-1-1’ time 时间 ‘12:25:36’ datetime 日期时间 ‘2021-1-1 22:06:44’ timestamp 自动存储记录修改时间[如果修改表的数据，这个字段自动更新] 4.6 Logic类型【了解】 Logic类型使用bit表示，它只能存储两个值0或者1 4.7 数据类型的属性 MySQL关键字 含义 NULL 数据列可包含NULL值 NOT NULL 数据列不允许包含NULL值 DEFAULT 默认值 PRIMARY KEY 主键 AUTO_INCREMENT 自动递增，适用于整数类型 CHARACTER SET name 指定一个字符集 5.MySQL表的相关操作DDL 5.1 创建表 5.1.1 语法 create table &lt;表名&gt;( 字段名 数据类型 属性, 字段名 数据类型 属性, 字段名 数据类型 属性, 字段名 数据类型 属性 ) 5.1.2，实例创建一个学生表tb_student CREATE TABLE tb_student( id int COMMENT '学生编号', stu_name varchar(20) COMMENT '学生姓名', stu_age int COMMENT '学生年龄', stu_sex char(1) COMMENT '学生性别', stu_hobby varchar(255) COMMENT '学生爱好' ); 5.1.3,创建一个学生表tb_student并指定编码和存储引擎 CREATE TABLE tb_student( id int COMMENT '学生编号', stu_name varchar(20) COMMENT '学生姓名', stu_age int COMMENT '学生年龄', stu_sex char(1) COMMENT '学生性别', stu_hobby varchar(255) COMMENT '学生爱好' ) DEFAULT CHARSET=UTF8MB4,ENGINE INNODB; 5.2 数据存储的问题 以上的表创建成功之后，如果电脑关掉，那么内存的数据会清空，但是我们发现表还存在，那么说表的结构是存储在硬盘里面的，【那么存的哪的呢】 现在我们在数据库中创建了一个表，那么如我们把电脑重启，这个表还在不在呢？ 测试结果为 在 那是为什么呢？ 原因是当我们创建表个表之后，在我们数据库的文件系统里面就会有一个对应的文件存在 .frm文件：保存了每个表的元数据，包括表结构的定义等； .ibd文件：InnoDB引擎开启了独立表空间(my.ini中配置innodb_file_per_table = 1)产生的存放该表的数据和索引的文件。 5.3 查看表结构 创建表之后如何查看是否创建成功？可以通过desc命令来查看表结构 -- 第一种方式查看表结构 -- desc &lt;表名称&gt;; desc student; -- 第二种方式查看表结构 -- show create table &lt;表名称&gt;; show create table tb_student; 5.4 修改表结构 基本语法如下：alter table ; 5.4.1,向student表新增加一列stu_height学生身高 [语法] -- 语法如下： -- alter table &lt;表名称&gt; add column &lt;列名称&gt; &lt;数据类型&gt;; alter table student add column stu_height int(11); -- 查看表结构 desc student; 5.4.1,删除student表中的学生身高 [语法] -- 语法如下： -- alter table &lt;表名称&gt; drop column &lt;列名称&gt;; alter table student drop column stu_height; 5.4.1,例如修改stu_sex 为 student_sex 数据类型修改为 varchar(30) 【语法】 -- 语法如下： -- alter table &lt;表名称&gt; change column &lt;原列名称&gt; &lt;新列名称&gt; &lt;数据类型&gt;; -- 修改stu_sex 为 student_sex 数据类型修改为 varchar(30) alter table student change column stu_sex student_sex varchar(30); 5.4.1,将学生性别修改为int类型 【语法】 -- 语法如下： -- alter table &lt;表名称&gt; modify column &lt;原来的列名称&gt; &lt;新的数据类型&gt;; -- 例如： alter table student modify column student_age int(11); 5.5 删除表 1.1.1 直接删除 -- drop table &lt;表名称&gt;; drop table EMP_bak; 1.1.2 删除之前先判断表是否存在 -- drop table if exists &lt;表名称&gt;; -- 刪除之前先做校验，表在数据库中存在才删除 drop table if exists EMP_bak; 5.6 显示当前库的所有表 show tables; 6，MySQL表里面数据的相关操作DML 6.1，添加数据 6.1.1，一条一条的添加 【语法】 insert into &lt;表名&gt;(字段名1，字段名2，字段名N) values(值1，值2，值N); insert into &lt;表名&gt; values(表里面已存在的所有字段的值) 【实例】 insert into tb_student(id,stu_name,stu_age,stu_sex,stu_hobby) values(1,'小明',22,1,"DOTA"); 6.1.2，一组一组的加 【语法】 insert into tb_student(id,stu_name,stu_age,stu_sex,stu_hobby) values(3,'小丽',22,1,"DOTA"),(3,'小芳',22,1,"DOTA"); 6.2，修改数据 6.2.1，一条一条的修改 【语法】 update &lt;表名&gt; set 字段名=修改后的值,字段名=修改后的值……………… where id=1; 【实例】 把id=1的学生名字变成张大明 update tb_student set stu_name='张大名' where id=1; 6.2.2，一组一组的修改 -- 把表里面所有的名字变成张大名 update tb_student set stu_name='张大名' -- 把年龄大于20的学生爱好变成 LOL update tb_student set stu_hobby='LOL' where stu_age&gt;20 6.3，删除数据 6.3.1，一条一条的修改 【语法】 delete from &lt;表名&gt; where 条件 【实例】删除ID=1的学生 delete from tb_student where id=1; 6.3.2，一组一组的修改 【实例】 删除所有学生信息 delete from tb_student; 【实例】 删除 年龄大于20的学生 delete from tb_student where stu_age&gt;20; 6.3.3，truncate关键字 原理：删表再重建 truncate是DDL，删除所有数据，不支持where，不能回滚 delete是DML，可以删除部分数据，因为支持where，可以回滚 总体上truncate效率比delete高，他们都只能删除数据不能删除表结构，只有drop才能删除表结构 7. 数据完整性 为什么要学习数据完整性？我们上面创建的tb_student表缺乏安全性，还会有重复的id，这些都是脏数据。 什么是数据完整性？需要为MySQL数据库中的表定义一个规则，确保表中数据的有效性、一致性、安全性、尽最大的可能减少脏数据，重复的数据(冗余)。、 7.1 主键约束 特点：非空并且唯一 添加方法[创建表时添加] ```sql lite CREATE TABLE tb_student( id int primary key COMMENT ‘学生编号’, stu_name varchar(20) COMMENT ‘学生姓名’, stu_age int COMMENT ‘学生年龄’, stu_sex char(1) COMMENT ‘学生性别’, stu_hobby varchar(255) COMMENT ‘学生爱好’ ); ```sql CREATE TABLE tb_student( id int COMMENT '学生编号', stu_name varchar(20) COMMENT '学生姓名', stu_age int COMMENT '学生年龄', stu_sex char(1) COMMENT '学生性别', stu_hobby varchar(255) COMMENT '学生爱好', primary key (id) ); 主键的自动增长 【添加数据的时不用给主键设置值，会根据数据库里面的数据进行自动递增】 【设置方式】 CREATE TABLE tb_student( id int auto_increment COMMENT '学生编号', stu_name varchar(20) COMMENT '学生姓名', stu_age int COMMENT '学生年龄', stu_sex char(1) COMMENT '学生性别', stu_hobby varchar(255) COMMENT '学生爱好', primary key (id) ); 7.2 非空约束 特点：不能为空 语法 属性名 类型 not null CREATE TABLE tb_student( id int auto_increment COMMENT '学生编号', stu_name varchar(20) not null COMMENT '学生姓名', stu_age int COMMENT '学生年龄', stu_sex char(1) COMMENT '学生性别', stu_hobby varchar(255) COMMENT '学生爱好', primary key (id) ); 7.3 唯一约束 特点：不能重复 语法 属性名 类型 UNIQUE CREATE TABLE tb_student( id int auto_increment COMMENT '学生编号', stu_name varchar(20) UNIQUE COMMENT '学生姓名', stu_age int COMMENT '学生年龄', stu_sex char(1) COMMENT '学生性别', stu_hobby varchar(255) COMMENT '学生爱好', primary key (id) ); 7.4 默认约束 特点：当用户添加数据时，如果没有指定某一列的数据，那么就使用默认值 语法 字段名 类型 DEFAULT 默认值 【设置性别默认为‘1’】 CREATE TABLE tb_student( id int auto_increment COMMENT '学生编号', stu_name varchar(20) UNIQUE COMMENT '学生姓名', stu_age int COMMENT '学生年龄', stu_sex char(1) DEFAULT '1' COMMENT '学生性别', stu_hobby varchar(255) COMMENT '学生爱好', primary key (id) ); 7.5 外键约束 以学生和班级为例 【创建班级表】 create table tb_cls( clsId int primary key auto_increment comment '班级编号', clsName varchar(20) UNIQUE comment '班级名称', clsRemark varchar(50) comment '班级备注' ) insert into tb_cls(clsId,clsName,clsRemark) values(1,"JAVA一班","JAVA一班"); insert INTO tb_cls(clsId,clsName,clsRemark) values(2,"JAVA二班","JAVA二班"); insert into tb_cls(clsId,clsName,clsRemark) values(3,"JAVA三班","JAVA三班"); 【创建学生表】 create table tb_student( stuId int primary key auto_increment COMMENT '学生编号', stuName varchar(20) UNIQUE COMMENT '学生姓名', stuAge int COMMENT '学生年龄', stuSex char(1) DEFAULT '1' COMMENT '学生性别', stuHobby varchar(255) COMMENT '学生爱好', clsId int comment '班级编号', #添加外键 FOREIGN key(clsId) REFERENCES tb_cls(clsId) ) insert into tb_student(stuName,stuAge,stuSex,stuHobby,clsId) values('小明1',22,1,"DOTA",1); insert into tb_student(stuName,stuAge,stuSex,stuHobby,clsId) values('小明2',22,1,"DOTA",2); insert into tb_student(stuName,stuAge,stuSex,stuHobby,clsId) values('小明3',22,1,"DOTA",3); insert into tb_student(stuName,stuAge,stuSex,stuHobby,clsId) values('小明4',22,1,"DOTA",1); insert into tb_student(stuName,stuAge,stuSex,stuHobby,clsId) values('小明5',22,1,"DOTA",2); insert into tb_student(stuName,stuAge,stuSex,stuHobby,clsId) values('小明6',22,1,"DOTA",1); 1. 外键定义的语法 通常在create table和alter table语句中定义外键约束，基本语法如下： [CONSTRAINT [symbol]] FOREIGN KEY [index_name] (col_name, ...) REFERENCES tbl_name (col_name,...) [ON DELETE reference_option] [ON UPDATE reference_option] reference_option: RESTRICT | CASCADE | SET NULL | NO ACTION | SET DEFAULT CONSTRAINT symbol 为外键约束名称，如果没有定义，InnoDB表会自动生成一个名称，这个名称在数据库里面必须唯一。 ON DELETE、ON UPDATE表示事件触发时的动作，可设置值为： CASCADE，更新或者删除父表记录时，子表中的相应记录同步更新或者删除。由级联更新或者删除导致的子表记录修改，不会触发子表的触发器执行。 SET NULL，更新或者删除父表记录时，子表中的相应记录字段设置为NULL，前提是子表中相应字段不能定义为NOT NULL。 RESTRICT，有外键关系约束时，拒绝父表记录的更新和删除操作。 NO ACTION，无动作，实际功能与RESTRICT相同。 SET DEFAULT，仅仅解析器能识别，实际功能未实现。 2. 级联更新和级联删除 当父表对外键关联的字段进行update、delete操作时，子表对应的字段值也会同步变化，称之为级联更新或者级联删除。当外键定义时，设置 referential action 为CASCADE即可实现级联更新与删除。 示例： foreign key(parent_id) references parent(id) on update cascade foreign key(parent_id) references parent(id) on delete cascade foreign key(parent_id) references parent(id) on update cascade on delete cascade 3. 外键约束案例 3.1 外键约束字段值 # 创建父表 create table parent(id int, primary key(id)); # 创建子表 create table child(id int, parent_id int, foreign key(parent_id) references parent(id), primary key(id)); 子表child会自动在parent_id字段上加上索引。往子表插入数据或者更新数据时，parent_id字段值必须为父表parent中已经存在的值，否则会报错。如下： Cannot add or update a child row: a foreign key constraint fails (`db`.`child`, CONSTRAINT `child_ibfk_1` FOREIGN KEY (`parent_id`) REFERENCES `parent` (`id`)) 删除父表中有外键约束的记录时，也会报错，如下： Cannot delete or update a parent row: a foreign key constraint fails (`db`.`child`, CONSTRAINT `child_ibfk_1` FOREIGN KEY (`parent_id`) REFERENCES `parent` (`id`)) 3.2 外键级联更新 # 创建父表 create table parent(id int, primary key(id)); # 创建子表 create table child(id int, parent_id int, foreign key(parent_id) references parent(id) on update cascade, primary key(id)); 更新父表parent的id字段值，那么子表字段parent_id中相应的值也会同步更新。 3.3 外键级联删除 # 创建父表 create table parent(id int, primary key(id)); # 创建子表 create table child(id int, parent_id int, foreign key(parent_id) references parent(id) on delete cascade, primary key(id)); 删除父表parent的某个id字段值的记录，那么子表字段parent_id中相应值的记录也会同步删除。 3.4 删除外键 alter table child drop foreign key child_ibfk_1; 3.5 创建外键 alter table child add foreign key(parent_id) references parent(id); 4. 外键约束的条件和限制 父表和子表必须为同一种存储引擎，且不能定义为临时表。 创建外键约束需要有REFERENCES权限。 外键约束中使用的字段必须有相似的数据类型，整型的大小必须相同，有无符号也必须相同。字符串类型的长度可以不相同，但是字符集和校验规则必须相同。 外键约束的两个字段可以在同一个表中，但是不能是同一个字段。 外键约束的字段上必须要有索引，以便加快外键检查，如果引用表上的外键字段没有索引的话，MySQL会自动创建一个索引。 不支持外键字段上的前缀索引，blob和text字段不能用于外键。 InnoDB表外键约束不支持分区。 一个有外键约束的表不能修改其存储引擎。 外键约束不能引用虚拟字段。 总结 外键就是一个主从关系 学生和班 多个学生可以属性同一个班级 一个班级里面可以有多个学生 【学生角度关系】 多对一 【班级角度关系】 一对多 问题，如果班级的信息在学生表里面出现了，那么班级默认是不能删除的 7.6 约束关键字总结 约束名称 关键字 主键约束 primary key 自增 auto_increment 非空约束 not null 唯一约束 unique 默认约束 default 外键约束 foreign key()…….references 父表(父表的字段) 8. 表关系 8.1 一对一（one-to-one）【了解】 如果表里面的字段非常多，那么我们可以把表拆成1对1 的关系，但是如果不拆，放在一张里面也行，只是后期数据查询时可以能慢 8.2 一对多/多对一（many-to-one）【掌握】 学生-班级 【创建班级表】 create table tb_cls( clsId int primary key auto_increment comment '班级编号', clsName varchar(20) UNIQUE comment '班级名称', clsRemark varchar(50) comment '班级备注' ) insert into tb_cls(clsId,clsName,clsRemark) values(1,"JAVA一班","JAVA一班"); insert INTO tb_cls(clsId,clsName,clsRemark) values(2,"JAVA二班","JAVA二班"); insert into tb_cls(clsId,clsName,clsRemark) values(3,"JAVA三班","JAVA三班"); 【创建学生表】 create table tb_student( stuId int primary key auto_increment COMMENT '学生编号', stuName varchar(20) UNIQUE COMMENT '学生姓名', stuAge int COMMENT '学生年龄', stuSex char(1) DEFAULT '1' COMMENT '学生性别', stuHobby varchar(255) COMMENT '学生爱好', clsId int comment '班级编号', #添加外键 FOREIGN key(clsId) REFERENCES tb_cls(clsId) ) insert into tb_student(stuName,stuAge,stuSex,stuHobby,clsId) values('小明1',22,1,"DOTA",1); insert into tb_student(stuName,stuAge,stuSex,stuHobby,clsId) values('小明2',22,1,"DOTA",2); insert into tb_student(stuName,stuAge,stuSex,stuHobby,clsId) values('小明3',22,1,"DOTA",3); insert into tb_student(stuName,stuAge,stuSex,stuHobby,clsId) values('小明4',22,1,"DOTA",1); insert into tb_student(stuName,stuAge,stuSex,stuHobby,clsId) values('小明5',22,1,"DOTA",2); insert into tb_student(stuName,stuAge,stuSex,stuHobby,clsId) values('小明6',22,1,"DOTA",1); 关于一对多和多对一的删除问题 默认情况，是如果对应的班级有学生，班级是不能删除 可以设置如果要删除的班级下面有学生，可以让学生也删除 create table tb_student( stuId int primary key auto_increment COMMENT '学生编号', stuName varchar(20) UNIQUE COMMENT '学生姓名', stuAge int COMMENT '学生年龄', stuSex char(1) DEFAULT '1' COMMENT '学生性别', stuHobby varchar(255) COMMENT '学生爱好', clsId int comment '班级编号', #添加外键 FOREIGN key(clsId) REFERENCES tb_cls(clsId) ON DELETE CASCADE ) 可以设置如果要删除的班级下面有学生，让学生的班级编号设置为null create table tb_student( stuId int primary key auto_increment COMMENT '学生编号', stuName varchar(20) UNIQUE COMMENT '学生姓名', stuAge int COMMENT '学生年龄', stuSex char(1) DEFAULT '1' COMMENT '学生性别', stuHobby varchar(255) COMMENT '学生爱好', clsId int comment '班级编号', #添加外键 FOREIGN key(clsId) REFERENCES tb_cls(clsId) ON DELETE CASCADE #|--如果一方被删除，那么多方法引用的数据也会被删除 ) 【使用工具如何设置】 8.3 多对多（many-to-many）【掌握】 总结，多对多的关系必须建立中间表 中间表的里要使用联合主键+外键的规则 #一对多和多对一 以学生和班级为例 【创建班级表】 create table tb_cls( clsId int primary key auto_increment comment '班级编号', clsName varchar(20) UNIQUE comment '班级名称', clsRemark varchar(50) comment '班级备注' ) insert into tb_cls(clsId,clsName,clsRemark) values(1,"JAVA一班","JAVA一班"); insert INTO tb_cls(clsId,clsName,clsRemark) values(2,"JAVA二班","JAVA二班"); insert into tb_cls(clsId,clsName,clsRemark) values(3,"JAVA三班","JAVA三班"); 【创建学生表】 create table tb_student( stuId int primary key auto_increment COMMENT '学生编号', stuName varchar(20) UNIQUE COMMENT '学生姓名', stuAge int COMMENT '学生年龄', stuSex char(1) DEFAULT '1' COMMENT '学生性别', stuHobby varchar(255) COMMENT '学生爱好', clsId int comment '班级编号' #添加外键 FOREIGN key(clsId) REFERENCES tb_cls(clsId) ON DELETE RESTRICT ) insert into tb_student(stuName,stuAge,stuSex,stuHobby,clsId) values('小明',22,1,"DOTA",1); insert into tb_student(stuName,stuAge,stuSex,stuHobby,clsId) values('小荭',22,1,"DOTA",2); insert into tb_student(stuName,stuAge,stuSex,stuHobby,clsId) values('小丽',22,1,"DOTA",3); insert into tb_student(stuName,stuAge,stuSex,stuHobby,clsId) values('小芳',22,1,"DOTA",1); insert into tb_student(stuName,stuAge,stuSex,stuHobby,clsId) values('小花',22,1,"DOTA",2); insert into tb_student(stuName,stuAge,stuSex,stuHobby,clsId) values('小美',22,1,"DOTA",1); #现在是1-3号班级都有数据 # 创建一个科目表 create table tb_course( course_id int(11) auto_increment COMMENT '课程编号', course_name varchar(30) not null comment '课程名称', primary key(course_id) ) #创建一个学生和课程的关系表（一个学生可以选多个课 |一个课可以让多个学生选择） create table tb_student_course( stuId int , course_id int , score int, #联合主键的建立 primary key(stuId,course_id), #建立stuId的外键 FOREIGN key(stuId) REFERENCES tb_student(stuId), #建立course_id的外键 FOREIGN key(course_id) REFERENCES tb_course(course_id)); #小明[1]选择了JAVA[1] 分数为100分 insert into tb_student_course(stuId,course_id,score) values(1,1,100) #小明[1]选择了PHP[2] 分数为100分 insert into tb_student_course(stuId,course_id,score) values(1,2,100) # 下面的数据添加不进去，原因是10号学生不存在，违反的外键规则 insert into tb_student_course(stuId,course_id,score) values(10,2,100) 8.4 员工系统设计 8.4.1 要求 ​ 1，可以记录员工信息EMP ​ 2，可以记录公司所有的部门信息DEPT ​ 3，可以记录工资等级信息SALGRAGE 8.4.2 部门表（dept） № 名称 类型 描述 1 DEPTNO INT 表示部门编号 2 DNAME VARCHAR(20) 部门名称，最多由20个字符所组成 3 LOC VARCHAR(20) 部门所在的位置 8.4.3 员工表（emp） № 名称 类型 描述 1 EMPNO INT 雇员的编号 主键 2 ENAME VARCHAR(10) 雇员的姓名 4 MGR INT 雇员对应的领导编号，领导也是雇员 5 HIREDATE DATE 雇员的雇佣日期 6 JOB VARCHAR(10) 职位 7 SAL decimal(7,2) 基本工资，其中有两位小数，五倍整数，一共是七位 8 COMM decimal(7,2) 奖金，佣金 9 DEPTNO INT 雇员所在的部门编号 8.4.4 工资等级表（salgrade） № 名称 类型 描述 1 GRADE INT 工资的等级 主键 2 LOSAL decimal(7,2) 此等级的最低工资 3 HISAL decimal(7,2) 此等级的最高工资 8.4.5 脚本 -- ---------------------------- -- 创建部门表 -- ---------------------------- DROP TABLE IF EXISTS dept; CREATE TABLE dept ( DEPTNO int(11) NOT NULL COMMENT '部门编号', DNAME varchar(20) NOT NULL COMMENT '部门名称', LOC varchar(20) COMMENT '部门所在的位置', PRIMARY KEY (DEPTNO) ) ENGINE = InnoDB CHARACTER SET = utf8mb4 COMMENT = '部门表'; -- ---------------------------- -- 创建员工表 -- ---------------------------- DROP TABLE IF EXISTS emp; CREATE TABLE emp ( EMPNO int(11) NOT NULL COMMENT '雇员的编号', ENAME varchar(50) NOT NULL COMMENT '雇员的姓名', JOB varchar(50) NOT NULL COMMENT '职位', MGR int(11) NULL DEFAULT NULL COMMENT '雇员对应的领导编号', HIREDATE date NULL DEFAULT NULL COMMENT '雇员的雇佣日期', SAL decimal(7, 2) NULL DEFAULT NULL COMMENT '基本工资', COMM decimal(7, 2) NULL DEFAULT NULL COMMENT '奖金，佣金', DEPTNO int(11) NULL DEFAULT NULL COMMENT '雇员所在的部门编号', PRIMARY KEY (EMPNO), CONSTRAINT FK_EMP_DEPTNO FOREIGN KEY (DEPTNO) REFERENCES dept (DEPTNO) ON DELETE RESTRICT ON UPDATE RESTRICT ) ENGINE = InnoDB CHARACTER SET = utf8mb4 COMMENT = '员工表'; -- ---------------------------- -- 工资等级表 -- ---------------------------- DROP TABLE IF EXISTS salgrade; CREATE TABLE salgrade ( GRADE int(11) NOT NULL COMMENT '工资的等级 主键', LOSAL decimal(7, 2) NOT NULL COMMENT '此等级的最低工资', HISAL decimal(7, 2) NOT NULL COMMENT '此等级的最高工资', PRIMARY KEY (GRADE) ) ENGINE = InnoDB CHARACTER SET = utf8mb4 COMMENT = '工资等级表' ; -- ---------------------------- -- 部门表插入数据 -- ---------------------------- INSERT INTO DEPT VALUES (10, '财务部', '武汉'); INSERT INTO DEPT VALUES (20, '研发部', '武汉'); INSERT INTO DEPT VALUES (30, '销售部', '深圳'); INSERT INTO DEPT VALUES (40, '业务部', '上海'); -- ---------------------------- -- 员工表插入数据 -- ---------------------------- INSERT INTO EMP values (7369, 'SMITH', 'CLERK', 7902, '1980-12-17', 800.00, null, 20); INSERT INTO EMP values (7499, 'ALLEN', 'SALESMAN', 7698, '1981-02-20', 1600.00, 300.00, 30); INSERT INTO EMP values (7521, 'WARD', 'SALESMAN', 7698, '1981-02-22', 1250.00, 500.00, 30); INSERT INTO EMP values (7566, 'JONES', 'MANAGER', 7839, '1981-04-02', 2975.00, null, 20); INSERT INTO EMP values (7654, 'MARTIN', 'SALESMAN', 7698, '1981-09-28', 1250.00, 1400.00, 30); INSERT INTO EMP values (7698, 'BLAKE', 'MANAGER', 7839, '1981-05-01', 2850.00, null, 30); INSERT INTO EMP values (7782, 'CLARK', 'MANAGER', 7839, '1981-06-09', 2450.00, null, 10); INSERT INTO EMP values (7788, 'SCOTT', 'ANALYST', 7566, '1987-04-19', 3000.00, null, 20); INSERT INTO EMP values (7839, 'KING', 'PRESIDENT', null, '1981-11-17', 5000.00, null, 10); INSERT INTO EMP values (7844, 'TURNER', 'SALESMAN', 7698, '1981-09-08', 1500.00, 0.00, 30); INSERT INTO EMP values (7876, 'ADAMS', 'CLERK', 7788, '1987-05-23', 1100.00, null, 20); INSERT INTO EMP values (7900, 'JAMES', 'CLERK', 7698, '1981-12-03', 950.00, null, 30); INSERT INTO EMP values (7902, 'FORD', 'ANALYST', 7566, '1981-12-03', 3000.00, null, 20); INSERT INTO EMP values (7934, 'MILLER', 'CLERK', 7782, '1982-01-23', 1300.00, null, 10); -- ---------------------------- -- 工资等级表插入数据 -- ---------------------------- INSERT INTO SALGRADE (GRADE, LOSAL, HISAL) values (1, 700, 1200); INSERT INTO SALGRADE (GRADE, LOSAL, HISAL) values (2, 1201, 1400); INSERT INTO SALGRADE (GRADE, LOSAL, HISAL) values (3, 1401, 2000); INSERT INTO SALGRADE (GRADE, LOSAL, HISAL) values (4, 2001, 3000); INSERT INTO SALGRADE (GRADE, LOSAL, HISAL) values (5, 3001, 9999); 9，单表数据查询 查询是MYSQL学习里面最重要的环节 sql语句的注释 SQL中的注释分为单行注释和多行注释。顾名思义，单行注释就是对一行进行注释，多行注释就是同时对多行进行注释。 一、单行注释 SQL语句中的单行注释使用 – create database database_x --创建数据库database_x 1 二、多行注释 SQL语句中的多行注释采用 /…/ create database database_x /* 创建一个数据库 名字叫做database_x */ 9.1 最简单的查询方式 1，查询部门所有信息 SELECT * FROM DEPT; 2，查询所有部门的部门编号和名称 SELECT DEPTNO,DNAME FROM DEPT; 3,查询所有员工信息 SELECT * FROM EMP; 4,查询所有员的名字和入职时间 SELECT ENAME,HIREDATE FROM EMP; 9.2 使用算术表达式 1,查询所有员工名字和工资，并在原有的工资基础加10% SELECT ENAME,SAL*1.1 FROM EMP; 2,查询所有员工名字和工资，并在原有的工资基础减10% SELECT ENAME,SAL*0.9 FROM EMP; 3,查询所有员工名字和工资，并在原有的工资基础加1000 SELECT ENAME,SAL+1000 FROM EMP; 4,查询所有员工名字和工资，并在原有的工资基础减500 SELECT ENAME,SAL-500 FROM EMP; 9.3 使用字段别名 1，查询所有部门信息并翻译表头 SELECT DEPTNO AS '部门 编号',DNAME AS 部门名称,LOC AS 部门地址 FROM DEPT; 2,在SQL查询中，AS可以不写 SELECT DEPTNO '部门 编号',DNAME 部门名称,LOC 部门地址 FROM DEPT; 9.4 去重查询DISTINCT 1，查询所有员工的部门编号 SELECT DEPTNO FROM EMP; 2,过虑上一个查询部门编号 SELECT DISTINCT DEPTNO FROM EMP; 3,查询所有员工的部门编号和工种[JOB] SELECT JOB,DEPTNO FROM EMP; 4,过虑上一个查询的数据 SELECT DISTINCT JOB,DEPTNO FROM EMP; 9.5 排序查询 ORDER BY 1，查询所有员工信息，并按工资升序【ASC--可以不写】 SELECT * FROM EMP ORDER BY SAL ASC 2，查询所有员工信息，并按工资降序【DESC】 SELECT * FROM EMP ORDER BY SAL DESC 3,查询所有员工信息，并按工资降序【DESC】 如果工资相同，按入职时间升序 SELECT * FROM EMP ORDER BY SAL DESC ,HIREDATE ASC 9.6 分页查询LIMIT 1,查询员工的前三条数 SELECT * FROM EMP LIMIT 3; 2, 真正的分页查询 应该有页码 每页条数 pageNum 页码 pageSize 每页的条数 pageNum pageSize 第一页 1 5 第二页 2 5 第三页 3 5 SELECT * FROM EMP; SELECT * FROM EMP LIMIT A,B # 第一页的查询 SELECT * FROM EMP LIMIT 0,5 # 第一页的查询 SELECT * FROM EMP LIMIT 5,5 # 第二页的查询 SELECT * FROM EMP LIMIT 10,5 # 第三页的查询 算 A =(pageNum-1)*pageSize A是指从第一条开始的便宜量 B =pageSize 9.7 **合并查询 **UNION 1,查询部门编号为10的员工 SELECT * FROM EMP WHERE DEPTNO=10; 2,查询部门编号为30的员工 SELECT * FROM EMP WHERE DEPTNO=30; 3,把上面两个查询的结果合并到一起 SELECT * FROM EMP WHERE DEPTNO=10 UNION SELECT * FROM EMP WHERE DEPTNO=30; 4,查询部门编号为10或者20的员工 SELECT * FROM EMP WHERE DEPTNO=10 OR DEPTNO=20; 5，查询部门编号20的员工 SELECT * FROM EMP WHERE DEPTNO=20; 6,把4和5的查询结构进行合并 SELECT * FROM EMP WHERE DEPTNO=10 OR DEPTNO=20 UNION #合并并去重 SELECT * FROM EMP WHERE DEPTNO=20 7,把4和5的查询结构进行合并 不去重 SELECT * FROM EMP WHERE DEPTNO=10 OR DEPTNO=20 UNION ALL #只合并，不去重 SELECT * FROM EMP WHERE DEPTNO=20 8，如果字段名不一样，可不可以合并[--不可以] SELECT EMPNO,ENAME,SAL FROM EMP UNION SELECT JOB,SAL,DEPTNO FROM EMP #合并的原则，只要两个查询结果列数一样就可以合并 10，WHERE子句 作用：对查询结果进行筛选 10.1 用法举例 select * from emp where deptno=10; #查询所有部门ID=10的员工 select * from emp where ename = 'JACK';#查询名字等于JACK的员工 select * from emp where hiredate = '2020-12-12'; 查询入职时间为2020-12-12的工 注意： 字符串和日期值要用单引号扩起来 字符串大小写敏感 日期值格式敏感，缺省的日期格式是‘YYYY-MM-DD HH:mm:ss’ 10.2 查询条件中可以使用比较运算符 &gt; &gt;= &lt; &lt;= != &lt;&gt; = 注意：MySQL使用=运算符来判断表达式是否相等，它没有== ​ Java使用!=表示不等于，MySQL也支持。但是我们不要使用，效率太低了 ​ MySQL使用的不等于使用&lt;&gt; #1，比较运算符 1,查询工资大于2500的所有员工 SELECT * FROM EMP WHERE SAL&gt;2500; 2,查询部门编号不等于20的员工 SELECT * FROM EMP WHERE DEPTNO&lt;&gt;20 3,查询工资在800-1100之间的员工信息 SELECT * FROM EMP WHERE SAL BETWEEN 800 AND 1100; || SELECT * FROM EMP WHERE SAL&gt;=800 AND SAL &lt;=1100; 4,查询JOB 为 CLERK SALESMAN MANAGER的员工 SELECT * FROM EMP WHERE JOB IN('CLERK','SALESMAN','MANAGER') 10.3 使用LIKE运算符执行模糊查询（通配查询） LIKE 像 1,查询出所有员工里面名字以S开头的 SELECT * FROM EMP WHERE ENAME LIKE 'S%' 2,查询出所有员工里面名字包含S的 SELECT * FROM EMP WHERE ENAME LIKE '%S%' 3,查询出所有员工里面字以S开头，并且名字长度为5的员工 SELECT * FROM EMP WHERE ENAME LIKE 'S____'; 10.4 使用IS NULL运算符进行空值判断 1,查询所有员工里面奖金为NULL的员工 SELECT * FROM EMP WHERE COMM IS NULL; 2,查询所有员工里面部门编号为30 并且奖金不为空的 SELECT * FROM EMP WHERE DEPTNO=30 AND COMM IS NOT NULL; 10.5 查询条件中可以使用逻辑运算符 and 前后的条件都为true or 前后的条件满足一个就可以了 in(1,2,3,4,5) 在XX里面 以集合里面的所有数据进行等值判断 not in(1,2,3,4,5) 不在集合里面 对集合里面的所有数据做&lt;&gt;判断 1,查询员工表里面部门编号为10 并且工资大于1000 select * from emp where deptno = 10 and sal &gt; 1000; 2，查询员工表里面部门编号为10 或者 JOB 为 CLERK select * from emp where deptno = 10 or job = ‘CLERK’; || select * from emp where deptno = 10 UNION select * from emp where job = ‘CLERK’; 3,查询员工工资不在800, 1500, 2000里面的员工信息 SELECT * FROM EMP WHERE SAL NOT IN(800, 1500, 2000) SQL优化问题 AND: 把检索结果较少的条件放到后面 OR: 把检索结果较多的条件放到后面 10.6 四种运算符优先级：算术&gt;连接&gt;比较&gt;逻辑 可使用小括号强行改变运算顺序 select * from emp where job='SALESMAN' or job='CLERK' and sal&gt;=1280; select * from emp where (job='SALESMAN' or job='CLERK') and sal&gt;=1280; 11 聚合函数 使用函数可以大大提高SELECT语句操作数据库的能力。它给数据的转换和处理提供了方便。 函数只是将取出的数据进行处理，不会改变数据库中的值。 11.1 函数的分类 本质就是方法 11.1.1 单行函数 对表里面的某一个字段进行处理 Ø 数学函数 Ø 字符串函数 Ø 日期和时间函数 Ø 条件判断函数 Ø 系统信息函数 Ø 加密函数 Ø 格式化函数 11.1.2 多行函数 对表里面某一组字段数据进行数据 仅适用数值型的多行函数 sum() 求和 avg() 求平均值 适用任何类型数据 count() 计数 max() 求最大值 min() 求最小值 11.2 单行函数 11.2.1 数学函数 （1）ABS(x) 返回x的绝对值 SELECT ABS(-10); （2）PI() 返回圆周率π，默认显示6位小数 SELECT PI(); （3）SQRT(x) 返回非负数的x的二次方根 SELECT SQRT(16) （4）MOD(x,y) 返回x被y除后的余数 SELECT MOD(3,2); （5）CEIL(x) 向上取整 SELECT CEIL(9.000001); （6）FLOOR(x) 向下取整 SELECT FLOOR(9.99999999); （7）ROUND(x)、ROUND(x,y) 前者返回最接近于x的整数，即对x进行四舍五入；后者返回最接近x的数，其值保留到小数点后面y位，若y为负值，则将保留到x到小数点左边y位 SELECT ROUND(4.51312312); SELECT ROUND(4.51312312,2); （8）POW(x,y)和、POWER(x,y) 返回x的y次乘方的值 SELECT POW(2,4) （9）RAND(x) 返回0-1之间的随机小数 X是种子值 如果定死那么返回的值就是一样的 SELECT RAND(); （10）查询员工数据，返回员工名字和工资 并对工资向上取整 SELECT ENAME,CEIL(SAL) AS SAL FROM EMP; 11.2.1 字符串函数 （1）CHAR_LENGTH(str) 计算字符串字符个数 SELECT CHAR_LENGTH("HELLO"); |--查询员工表里面员工姓名及员工的姓名的字符长度 SELECT ENAME,CHAR_LENGTH(ENAME) FROM EMP ; |--查询员工表里面员工姓名长度为5的员工的所有信息 SELECT * FROM EMP WHERE CHAR_LENGTH(ENAME)=5 （2）CONCAT(s1,s2，...) 返回连接参数产生的字符串，一个或多个待拼接的内容，任意一个为NULL则返回值为NULL SELECT CONCAT('A','B','C'); |--查询员的表里面的数据 要求把员工ID和员的姓名使用-连接在一起 SELECT CONCAT(EMPNO,'-',ENAME) FROM EMP ; （3）CONCAT_WS(x,s1,s2,...) 返回多个字符串拼接之后的字符串，每个字符串之间有一个x SELECT CONCAT_WS('-','A','B','C'); |--查询员的表里面的数据 要求把员工ID和员的姓名使用-连接在一起 SELECT CONCAT_WS('-',EMPNO,ENAME) FROM EMP ; （4）LOWER(str)UPPER(str)前两者将str中的字母全部转换成小写，后两者将字符串中的字母全部转换成大写 SELECT LOWER('HELLO'); SELECT UPPER('hellO'); （5）TRIM(s) 返回字符串s删除了两边空格之后的字符串 SELECT TRIM(' ABC ') （6）REPLACE(s,s1,s2) 返回一个字符串，用字符串s2替代字符串s中所有的字符串s1 SELECT REPLACE('hello world','l','L'); （7）SUBSTRING(s,n,len)两个函数作用相同，从字符串s中返回一个第n个字符开始、长度为len的字符串 SELECT SUBSTRING("HELLO WORLD",1,2); |--查询所有员的的名字 并取出员工名字的第一个字母 并转成小写 SELECT SUBSTRING(ENAME,1,1) FROM EMP; SELECT LOWER(SUBSTRING(ENAME,1,1)) FROM EMP; （8）REVERSE(s) 将字符串s反转 SELECT REVERSE("HELLO"); 11.2.1 日期和时间函数 （1）CURDATE()、CURRENT_DATE()将当前日期按照"YYYY-MM-DD"或者"YYYYMMDD"格式的值返回，具体格式根据函数用在字符串或是数字语境中而定 SELECT CURDATE(),CURRENT_DATE(); （2）CURRENT_TIMESTAMP()、LOCALTIME()、NOW()、SYSDATE()这四个函数作用相同，返回当前日期和时间值，格式为"YYYY_MM-DD HH:MM:SS"或"YYYYMMDDHHMMSS"，具体格式根据函数用在字符串或数字语境中而定 SELECT CURRENT_TIMESTAMP(),LOCALTIME(),NOW(),SYSDATE(); （3）MONTH(date)和MONTHNAME(date)前者返回指定日期中的月份，后者返回指定日期中的月份的名称 SELECT MONTH(SYSDATE()) ,MONTHNAME(SYSDATE()); （4）WEEK(d)、WEEKOFYEAR(d)前者计算日期d是一年中的第几周，后者计算某一天位于一年中的第几周 SELECT WEEK('2021-11-11'),WEEKOFYEAR('2021-11-11') （5）DAYOFYEAR(d)、DAYOFMONTH(d)前者返回d是一年中的第几天，后者返回d是一月中的第几天 SELECT DAYOFYEAR(NOW()),DAYOFMONTH(NOW()); （6）EXTRACT(type FROM date)从日期中提取一部分，type可以是YEAR、YEAR_MONTH、MONTH、DAY、DAY_HOUR、DAY_MINUTE、DAY_SECOND、DAY_MICROSECOND、 SELECT EXTRACT(YEAR FROM NOW()),EXTRACT(YEAR_MONTH FROM NOW()),EXTRACT(MONTH FROM NOW()),EXTRACT(DAY FROM NOW()); （7）TimeStampDiff(间隔类型，前一个日期，后一个日期) 例如距离现在差了多少年：TimeStampDiff(year, 前一个日期, now()) 间隔类型有：second秒，minute分，hour时，day天，week周，month月，quarter季度，year年 SELECT TimeStampDiff(month,'1990-1-3',NOW()) 作业：计算EMP表里面35年前入职的员工 SELECT * FROM EMP WHERE TimeStampDiff(year,HIREDATE,NOW())&gt;35; （8）DATE_ADD(date,INTERVAL expr type)、ADD_DATE(date,INTERVAL expr type)返回将起始时间加上expr type之后的时间， 比如DATE_ADD('2010-12-31 23:59:59', INTERVAL 1 SECOND)表示的就是把第一个时间加1秒 比如DATE_ADD('2021-11-20 23:59:59', INTERVAL 1 SECOND)表示的就是把第一个时间加1秒 SELECT DATE_ADD('2021-11-20 23:59:59', INTERVAL 1 YEAR) 11.2.1 if条件判断函数 （1）IF(expr,v1,v2)如果expr是TRUE则返回v1，否则返回v2 SELECT IF(1&gt;2,1,2); 查询员工表里面的数据，如果奖金为空就显示0.00 SELECT ENAME,JOB,SAL,IF(COMM IS NULL,0.00,COMM) FROM EMP; （2）IFNULL(v1,v2)函数 如果v1的值不为NULL，则返回v1，否则返回v2。 查询员工表里面的数据，如果奖金为空就显示0.00 SELECT ENAME,JOB,SAL,IFNULL(COMM,0.00) FROM EMP; （2）CASE expr WHEN v1 THEN r1 [WHEN v2 THEN v2] [ELSE rn] END 如果expr等于某个vn，则返回对应位置THEN后面的结果，如果与所有值都不想等，则返回ELSE后面的rn SELECT CASE 4 WHEN 1 THEN '第一名' WHEN 2 THEN '第二名' ELSE '第三名' END; |--查询员的信息里面的JOB ，要求把JOB翻译成中文 SELECT ENAME,JOB, CASE JOB WHEN 'CLERK' THEN '职员' WHEN 'SALESMAN' THEN '销售员' WHEN 'MANAGER' THEN '经理' WHEN 'ANALYST' THEN '财务' WHEN 'PRESIDENT' THEN '总经理' ELSE '未知' END FROM EMP; 11.2.1 系统函数 （1）VERSION()查看MySQL版本号 SELECT VERSION(); 11.2.1 加密函数 （1）PASSWORD(str)从原明文密码str计算并返回加密后的字符串密码，注意这个函数的加密是单向的（不可逆），因此不应将它应用在个人的应用程序中而应该只在MySQL服务器的鉴定系统中使用 SELECT PASSWORD('123456') 11.3 多行函数 对一组数据进行运算，针对一组数据（多行记录）只返回一个结果，也称分组函数 11.3.1，多行函数的作用 对一组数据进行处理，返回一行一列的数据 11.3.2，常用的多行函数 sum() avg() 仅适用数值型 count() max() min() 适用任何类型数据 11.3.3，多行函数和空值及count的说明 多行函数除了count(*)外，都跳过空值而处理非空值 可使用IF()函数强制多行函数处理空值 count(*)返回组中总记录数目； 一般推荐使用count(1) count(exp)返回表达式exp值非空的记录数目； count(distinct(exp))返回表达式exp值不重复的、非空的记录数目。 11.3.4，GROUP BY 子句的使用 作用：将表中数据分成若干小组 语法 select 字段，[多行函数] from [where] group by [字段] 【注意事项】 出现在SELECT列表中的字段，如果不是包含在多行函数中，那么该字段必须同时在GROUP BY子句中出现。 错误：select ename,deptno,sum(sal) from emp group by deptno; |--以上的SQL在MYSQL中是不错的，但是在oracle是错的，在开发中避免这样写 包含在GROUP BY子句中的字段则不必须出现在SELECT列表中。 如果没有GROUP BY子句，SELECT列表中不允许出现字段（单行函数）与多行函数混用的情况 select empno, sal from emp; //合法 select avg(sal) from emp; //合法 select empno, avg(sal) from emp; //非法 不允许在WHERE 子句中使用多行函数 select deptno, avg(sal) from emp where avg(sal) &gt; 2000; //执行where时尚未执行groupby 及其他 group by deptno; 11.3.5，HAVEING子句的使用 注意点：因为在Group by后现不能跟where子句，那么如果想对分组之后的结果进行过滤只能使用having 语法 select 字段，[多行函数] from [where] group by [字段] having [表达式] 案例 5，按部门统计每个部门最高工资 最底工资，平均工资 并找出平均工资大于2000的数据 SELECT DEPTNO, MAX(SAL) 最高工资,MIN(SAL) 最低工资,AVG(SAL) 平均工资 FROM EMP GROUP BY DEPTNO HAVING 平均工资&gt;2000 SELECT DEPTNO, MAX(SAL) 最高工资,MIN(SAL) 最低工资,AVG(SAL) 平均工资 FROM EMP GROUP BY DEPTNO HAVING AVG(SAL)&gt;2000 小练习 统计人数小于4的部门的平均工资。 SELECT DEPTNO,COUNT(1) 人数,AVG(SAL) 平均工资 FROM EMP GROUP BY DEPTNO HAVING 人数&lt;4 统计各部门的最高工资，排除最高工资小于8000的部门。 SELECT DEPTNO,MAX(SAL) 最高工资 FROM EMP GROUP BY DEPTNO HAVING 最高工资&gt;=8000 显示部门编号大于10 的部门的人数，要求人数大于3 SELECT DEPTNO,COUNT(1) 人数 FROM EMP GROUP BY DEPTNO HAVING 人数&gt;3 AND DEPTNO&gt;10; |--逻辑 先把所有数据按部门分组，再找出人数&gt;3和部门编号大于10的 |--上面的不足，第一次就对所有数据进行分组【其它小于10的部门根本没有必须分组】 |--修改之后的逻辑 |--先找出部门编号大于10的所有员工，再进行分组 SELECT DEPTNO,COUNT(1) 人数 FROM EMP WHERE DEPTNO&gt;10 GROUP BY DEPTNO HAVING 人数&gt;3 12，连接查询（SQL92） 12.1 为什么要连接查询 当用户需要的数据来源于多张表的时候，我们就需要使用连接查询 12.2 连接查询概述 笛卡尔集 等值连接 非等值连接 外连接 自连接 说明。SQL92是1992年提出的查询语法，向上兼容 12.3 连接查询语法 12.3.1 语法规则 select table1.column,table2.column from table1,table2 where (连接条件) 12.3.2 特点 在 WHERE 子句中写入连接条件 当多个表中有重名列时，必须在列的名字前加上表名作为前缀 12.3.3 连接的类型： 等值连接 – Equijoin 非等值连接 – Non-equijoin 左连接 –LEFT JOIN 右连接 –RIGHT JOIN 自连接 – Self join 12.4 笛卡尔集 select * from dept;//4条记录 select * from emp; //14条记录 select * from dept,emp; ;//4*14=56条记录 总结 检索出的行的数目将是第一个表中的行数乘以第二个表中的行数 检索出的列的数目将是第一个表中的列数加上第二个表中的列数 应该保证所有联结都有where子句，不然数据库返回比想要的数据多得多的数据  12.5 等值连接 上面的笛卡尔集的查询里面的数据很多不是合法的数据，而我们要找的数据是员工表的部门编号和部门表的部门编号相等数据【左边表的某一列必须和右边表的某一列相等】 1,要求查询员的信息并查询员的所有部门信息 SELECT EMP.*,DEPT.DNAME,DEPT.LOC FROM EMP,DEPT WHERE EMP.DEPTNO=DEPT.DEPTNO; ||--简化 SELECT T1.*,T2.DNAME,T2.LOC FROM EMP AS T1,DEPT AS T2 WHERE T1.DEPTNO=T2.DEPTNO; ||--再简化 SELECT T1.*,T2.DNAME,T2.LOC FROM EMP T1,DEPT T2 WHERE T1.DEPTNO=T2.DEPTNO; 2,要求查询工资大于2000员工信息并查询员的所有部门信息 SELECT T1.*,T2.DNAME,T2.LOC FROM EMP T1,DEPT T2 WHERE T1.DEPTNO=T2.DEPTNO AND T1.SAL&gt;2000; 【注意点】 当被连接的多个表中存在同名字段时，须在该字段前加上”表名 另名.”前缀 可使用AND 操作符增加查询条件； 使用表别名可以简化查询 使用表名（表别名）前缀可提高查询效率； 12.6 非等值连接 如查连接条件不是使用=去判断的就叫非等值连接 1,查询出员工的工资等级[salgrage]及员工信息[emp] select t1.*,t2.* from emp t1,salgrade t2 where t1.sal&gt;=t2.losal and t1.sal&lt;=t2.hisal ||--等价写法 select t1.*,t2.* from emp t1,salgrade t2 where t1.sal between t2.losal and t2.hisal 12.7 自连接 特点：自己连接自己 何时使用：用户需要的数据来源同一张表的不同行 1,查询出员工信息及员的直接领导名字【差一条数据SQL92解决不了】 SELECT T1.*,T2.ENAME AS 领导名字 FROM EMP T1,EMP T2 WHERE T1.MGR=T2.EMPNO 12.8 三表连查 综合 1，查询出员工信息[emp]，及部门名称[dept] 及员工的工资等级[salgrade] SELECT T1.*,T2.DNAME,T3.GRADE FROM EMP T1,DEPT T2,SALGRADE T3 WHERE (T1.DEPTNO=T2.DEPTNO AND T1.SAL BETWEEN T3.LOSAL AND T3.HISAL) [开发中的注意点] 如果不必使用连表查询就不用边表查询 ，尽量使用单表查询【性能问题】 连接查询原则上对表的个是没有限制，但是开发中尽量不要超过5张表 13，连接查询（SQL99） 1.1 SQL99语法概述 SQL92的语法规则的缺点： 语句过滤条件和表连接的条件都放到了where子句中 。 当条件过多时，联结条件多，过滤条件多时，就容易造成混淆 SQL99修正了整个缺点，把联结条件，过滤条件分开来，包括以下新的TABLE JOIN的句法结构： 交叉连接（Cross join） 自然连接（Natural join） 使用Using子句建立连接 使用On子句建立连接 连接（ Outer join ） ​ 内连接INNER JOIN ​ 左连接LEFT JOIN ​ 右连接RIGHT JOIN 13.2 语法 select 字段列表 from table1 [cross join table2] | //1：交叉连接 [natural join table2] | //2：自然连接 [join table2 using (字段名)] | //3：using子句 [join table2 on (table1.column_name = table2.column_name)] | //4：on子句 [(left | right | full outer) join table2 on (table1.column_name = table2.column_name)]; //5：左/右/满外连接 WHERE 过滤条件 13.3 交叉连接 Cross join产生了一个笛卡尔集，其效果等同于在两个表进行连接时未使用WHERE子句限定连接条件; 可以使用where条件从笛卡尔集中选出满足条件的记录。 语法 select 字段列表 from table1 cross join table 2 select 字段列表 from table1,table2 [sql92写] 13.4 自然连接 Natural join基于两个表中的全部同名列建立等值连接 从两个表中选出同名列做等值连接 如果两个表中同名列的数据类型不同，则出错 不允许在参照列上使用表名或者别名作为前缀 自然连接的结果不保留重复的属性 select empno, ename, sal, deptno, dname from emp natural join dept 13.5 Using关键字 如果不希望参照被连接表的所有同名列进行等值连接，自然连接将无法满足要求，可以在连接时使用USING子句来设置用于等值连接的列（参照列）名。 using子句引用的列在sql任何地方不能使用表名或者别名做前缀 SELECT * FROM EMP T1 JOIN DEPT T2 USING(DEPTNO); 13.6 On子句 自然连接的条件是基于表中所有同名列的等值连接 为了设置任意的连接条件或者指定连接的列，需要使用ON子句 连接条件与其它的查询条件分开书写 使用ON 子句使查询语句更容易理解 查询出员工信息[emp]，及部门名称[dept] 及员工的工资等级[salgrade] 并只显示职位为 CLERK SALESMAN MANAGER SELECT T1.*,T2.DNAME,T2.LOC FROM EMP T1 JOIN DEPT T2 JOIN salgrade T3 ON(T1.DEPTNO=T2.DEPTNO AND T1.SAL BETWEEN T3.LOSAL AND T3.HISAL) WHERE T1.JOB IN('CLERK','SALESMAN','MANAGER') 13.7 外连接 13.7.1 左外联接 ​ 两个表在连接过程中除返回满足连接条件的行以外，还返回左表中不满足条件的行，这种连接称为左外联接。 13.7.2 右外联接 ​ 两个表在连接过程中除返回满足连接条件的行以外，还返回右表中不满足条件的行，这种连接称为右外联接。 13.7.3 满外联接 ​ 两个表在连接过程中除返回满足连接条件的行以外，还返回两个表中不满足条件的所有行，这种连接称为满外联接。 内连接:在SQL99规范中，内连接只返回满足连接条件的数据。 13.7.4 外连接举例 select t1.deptno, t1.dname,t2.empno,t2.ename from dept t1 left join emp t2 on(t1.deptno=t2.deptno); 14. 子查询 14.1 问题引入 如何查得所有比“CLARK”工资高的员工的信息 如何查得所有比"CLARK"工资高的员工的信息 1,根据CLARK的名字找到他的工资 SELECT SAL FROM EMP WHERE ENAME='CLARK' 2,再拿着上一个查询的结果去所有数据里面比较 SELECT * FROM EMP WHERE SAL &gt;(SELECT SAL FROM EMP WHERE ENAME='CLARK') 思考：查询工资高于平均工资的雇员名字和工资。 1,查询出平均工资 SELECT AVG(SAL) FROM EMP; 2,使用1的结果再去查询所有员工进行比较 SELECT ENAME,SAL FROM EMP WHERE SAL&gt;(SELECT AVG(SAL) FROM EMP) 思考：查询和SCOTT同一部门且比他工资低的雇员名字和工资。 1，根据SCOTT的名字找到部门编号 SELECT DEPTNO FROM EMP WHERE ENAME ='SCOTT' 2，根据SCOTT的名字找到工资 SELECT SAL FROM EMP WHERE ENAME='SCOTT' 3，使用1和2结果再去查询 SELECT ENAME,SAL FROM EMP WHERE DEPTNO=(SELECT DEPTNO FROM EMP WHERE ENAME ='SCOTT') AND SAL &lt;(SELECT SAL FROM EMP WHERE ENAME='SCOTT') 14.2 语法格式： select 字段列表 from table ​ where 表达式 operator (select 字段列表 from table); 14.3 特点 子查询在主查询前执行一次 主查询使用子查询的结果 使用子查询注意事项 在查询是基于未知值时应考虑使用子查询 子查询必须包含在括号内 建议将子查询放在比较运算符的右侧，以增强可读性。 如果子查询返回单行结果，则为单行子查询，可以在主查询中对其使用相应的单行记录比较运算符 如果子查询返回多行结果，则为多行子查询，此时不允许对其使用单行记录比较运算符 14.4 单行子查询 单行子查询只返回一行记录 对单行子查询可使用单行记录比较运算符 &lt; 、 &gt; 、 = 、 &gt;=、 &lt;= 、 &lt;&gt; 思考：查询工资最高的雇员名字和工资。 1,使用函数找到所有员的中的最高工资 SELECT MAX(SAL) FROM EMP; 2,使用1的结果去emp表里面查询 SELECT ENAME,SAL FROM EMP WHERE SAL=(SELECT MAX(SAL) FROM EMP) 查询职务和SCOTT相同，比SCOTT雇佣时间早的雇员信息 1,查询出SCOTT的职务[job] SELECT JOB FROM EMP WHERE ENAME='SCOTT'; 2,查询出SCOTT的雇佣时间 SELECT HIREDATE FROM EMP WHERE ENAME='SCOTT'; 3，使用1和2的结果再次进行查询 SELECT * FROM EMP WHERE JOB=(SELECT JOB FROM EMP WHERE ENAME='SCOTT') AND HIREDATE&lt;(SELECT HIREDATE FROM EMP WHERE ENAME='SCOTT') 查询工资比SCOTT高或者雇佣时间比SCOTT早的雇员的编号和名字 1,查询出SCOTT的工资 SELECT SAL FROM EMP WHERE ENAME='SCOTT'; 2，查询出SCOTT的入职时间 SELECT HIREDATE FROM EMP WHERE ENAME='SCOTT'; 3,使用上面的结果再次查询 SELECT ENAME,EMPNO FROM EMP WHERE SAL&gt;(SELECT SAL FROM EMP WHERE ENAME='SCOTT') OR HIREDATE &lt;(SELECT HIREDATE FROM EMP WHERE ENAME='SCOTT') 14.5 多行子查询 多行子查询返回多行记录 对多行子查询只能使用多行记录比较运算符 ALL 和子查询返回的所有值比较 ANY 和子查询返回的任意一个值比较 IN 等于列表中的任何一个 ```sql lite SELECT * FROM EMP; 查询工资低于任何一个’CLERK’的工资的雇员信息。 1，查询出所有CLERK的工资 SELECT SAL FROM EMP WHERE JOB=’CLERK’ 2,比较 SELECT * FROM EMP WHERE SAL&lt; ANY(SELECT SAL FROM EMP WHERE JOB=’CLERK’) 查询工资比所有的 ‘SALESMAN’都高的雇员的编号、名字和工资。 1,查询SALESMAN的所有工资 SELECT DISTINCT SAL FROM EMP WHERE JOB=’SALESMAN’ 2,比较 SELECT EMPNO,ENAME,SAL FROM EMP WHERE SAL&gt;ALL(SELECT DISTINCT SAL FROM EMP WHERE JOB=’SALESMAN’) 查询部门20中职务同部门10的雇员一样的雇员信息。 1,查询部门10中的所有职务 SELECT DISTINCT JOB FROM EMP WHERE DEPTNO=10 2,查询 SELECT * FROM EMP WHERE DEPTNO=20 AND JOB IN(SELECT DISTINCT JOB FROM EMP WHERE DEPTNO=10) ## 14.6 练习 ```sql 找出部门编号为20的所有员工中收入最高的职员 1,找出20部门中收入最高的工资 SELECT MAX(SAL) FROM EMP WHERE DEPTNO=20 2,再查询20里面的员工使用1的结果去比较 SELECT * FROM EMP WHERE DEPTNO=20 AND SAL=(SELECT MAX(SAL) FROM EMP WHERE DEPTNO=20) 查询每个部门平均薪水的等级 1，查询出部门的平均薪水 SELECT DEPTNO,AVG(SAL) AS AVGSAL FROM EMP GROUP BY DEPTNO; 2,使用1的结果和salgrade连接查询 SELECT T1.*, T2.* FROM salgrade T1 JOIN (SELECT DEPTNO,AVG(SAL) AS AVGSAL FROM EMP GROUP BY DEPTNO) T2 ON(T2.AVGSAL BETWEEN T1.LOSAL AND T1.HISAL) 15，视图 15.1 视图的定义及作用 15.1.1 定义 ​ 视图是从若干基本表和（或）其他视图构造出来的表。 在创建一个视图时，只是存放的视图的定义，也即是动态检索数据的查询语句，而并不存放视图对应的数据 在用户使用视图时才去求相对应的数据。所以视图被称作“虚表” 15.1.2 作用 ​ 可以限制对数据的访问，可以给用户授予表的特定部分的访问权限而不是整个表的访问权限。 可以使复杂的查询变的简单。在编写查询后，可以方便地重用它而不必知道他的基本查询细节。 提供了对相同数据的不同显示 15.2 视图的创建和删除 15.2.1 创建或修改单表视图 CREATE OR REPLACE VIEW MYVIEW1 AS SELECT EMPNO,ENAME,JOB,SAL FROM EMP; 15.2.2 视图的添加数据【了解】 1，如果视图里面的数据都来源一同一张表，并具没有包含的数据都是可以为空的，那么我们可以使用INSERT 去向这个视图里面添加数据 2，如果视图里面的数据来源于多张表，那么不能一次性修改或添加多个基表（视图里面包含的原始表）的数据 15.2.3 视图的删除 删除表 DROP TABLE IF EXISTS &lt;表名&gt; 删除数据 DELETE FROM &lt;表名&gt; WHERE 条件 删除视图 DROP VIEW &lt;视图名&gt; 15.3 统计视图 要求，创建一个视图，并显示部门名称 部门编号，部门的平均工资 ，最高工资，最低工资，部门人数，平均工资等级 要使用的表 emp dept salgrede CREATE OR REPLACE VIEW MYVIEW3 AS SELECT T1.DNAME 部门名称, T2.DEPTNO 部门编号, T2.SALAVG 平均工资, T2.SALMAX 最高工资, T2.SALMIN 最低工资, T2.EMPCOUNT 员工人数, T3.GRADE 平均工资等级 FROM DEPT T1 INNER JOIN ( SELECT DEPTNO, AVG( SAL ) SALAVG, MAX( SAL ) SALMAX, MIN( SAL ) SALMIN, COUNT( 1 ) EMPCOUNT FROM EMP GROUP BY DEPTNO ) T2 INNER JOIN SALGRADE T3 ON ( T1.DEPTNO = T2.DEPTNO AND T2.SALAVG BETWEEN T3.LOSAL AND T3.HISAL ); SELECT * FROM MYVIEW3; 15.4 基于其它视图的视图 CREATE OR REPLACE VIEW MYVIEW4 AS SELECT 部门名称,部门编号,最高工资,最低工资 FROM MYVIEW3 15.5 视图的总结 1.视图对应一个查询语句；视图是（从若干基本表和（或）其他视图构造出来的）表 2.视图进行查询，添加，修改，删除，其实就是对背后的表进行相应操作 3 虚表 在创建一个视图时，只是存放的视图的定义，也即是动态检索数据的查询语句，而并不存放视图对应的数据 4.视图的好处 1.安全 可以只显示部分行部分列的数据;可以对添加的数据进行检查；可以设置为只读视图 2.操作简单 16. MySQL存储引擎 16.1, InnoDB 引擎(MySQL5.5以后默认使用) MySQL 5.5 及以后版本中的默认存储引擎，他的优点如下： 灾难恢复性好 支持事务 使用行级锁 支持外键关联 支持热备份 对于InnoDB引擎中的表，其数据的物理组织形式是簇表（Cluster Table），主键索引和数据是在一起的，数据按主键的顺序物理分布 实现了缓冲管理，不仅能缓冲索引也能缓冲数据，并且会自动创建散列索引以加快数据的获取 支持热备份 16.2 MyISAM引擎 特性如下： 不支持事务 使用表级锁，并发性差 主机宕机后，MyISAM表易损坏，灾难恢复性不佳 可以配合锁，实现操作系统下的复制备份、迁移 只缓存索引，数据的缓存是利用操作系统缓冲区来实现的。可能引发过多的系统调用且效率不佳 数据紧凑存储，因此可获得更小的索引和更快的全表扫描性能 16.3 两种存储引擎的大致区别表现在： 1）InnoDB支持事务，MyISAM不支持，这一点是非常之重要。事务是一种高级的处理方式，如在一些列增删改中只要哪个出错还可以回滚还原，而MyISAM就不可以了。 2）MyISAM适合查询以及插入为主的应用，InnoDB适合频繁修改以及涉及到安全性较高的应用 3）InnoDB支持外键，MyISAM不支持 4）从MySQL5.5.5以后，InnoDB是默认引擎 5）InnoDB不支持FULLTEXT类型的索引 6）InnoDB中不保存表的行数，如select count() from table时，InnoDB需要扫描一遍整个表来计算有多少行，但是MyISAM只要简单的读出保存好的行数即可。注意的是，当count()语句包含where条件时MyISAM也需要扫描整个表。 7）对于自增长的字段，InnoDB中必须包含只有该字段的索引，但是在MyISAM表中可以和其他字段一起建立联合索引。 8）清空整个表时，InnoDB是一行一行的删除，效率非常慢。MyISAM则会重建表。 9）InnoDB支持行锁（某些情况下还是锁整表，如 update table set a=1 where user like ‘%lee%’ 有人说MYISAM只能用于小型应用，其实这只是一种偏见。 如果数据量比较大，这是需要通过升级架构来解决，比如分表分库，读写分离，而不是单纯地依赖存储引擎。 现在一般都是选用InnoDB了，主要是MyISAM的全表锁，读写串行问题，并发效率锁表，效率低，MyISAM对于读写密集型应用一般是不会去选用的。 16.4 总结 1.MyISAM类型不支持事务处理等高级处理，而InnoDB类型支持。 2.MyISAM类型的表强调的是性能，其执行速度比InnoDB类型更快，但是不提供事务支持，而InnoDB提供事务支持已经外部键等高级数据库功能。 16.5，相关设置 16.5.1，创建表时设置 create table test_table( id int(11) )ENGINE=INNODB ,DEFAULT CHARSET = UTF8; 16.5.2，设置默认的存储引擎 C:\ProgramData\MySQL\MySQL Server 5.7\my.ini 17.事务[mysql] 17.1 什么是事务 完成一个事情需要的一系列步骤(操作)，这些操作要么同时成功，要么同时失败 17.2 事务的基本操作 场景：有两个账户分别为张三和李四，他们默认都有1000块钱的余额。在这两个账户之间进行转账。 #1 创建账户表 create table tb_account( id int(11) auto_increment, user_name varchar(30) not null, account_blance int(11) not null, -- 账户余额 primary key (id) )ENGINE=INNODB,default charset =UTF8MB4; #2 向账户表里面添加两条测试数据 insert into tb_account(user_name,account_blance) values('ZS',1000),('LS',1000); # 3 执行张三向李四转账500 # ZS账户-500，LS账户+500 # 下面两个update语句要么同时执行成功要么同时执行失败 # 执行下列SQL语句会出现问题：张三的钱减少了，李四的钱没有加上。因为此时的两个update语句并没有使用事务来托管 update tb_account set account_blance=account_blance-500 where id=1; # 银行转帐异常情况：如机机房停电 update tb_account set account_blance=account_blance+500 where id=2; 17.3 事务的四大特征 原子性：事务每一步都是不可再分 一致性：张三和李四账户一共2000块钱，不管转账多少次总金额不变 持久性：当一个事务执行成功(完毕)，数据会持久化到磁盘的数据文件中。例如转账成功：张三余额变为500，李四余额变为1500. 隔离性：A事务和B事务同时操作一份数据，相互之间不影响。 17.4 事务的提交方式 1 自动提交，MySQL默认为自动提交。 不需要写commit;就会自动将DML语句持久化提交 2 手动提交，Oracle默认手动提交。 如何在MySQL中查看提交方式： -- 查询结果为1表示自动提交，0表示手动提交 select @@autocommit; -- 修改提交方式（自动提交修改为手动提交） set @@autocommit = 0 ; 17.5 事务的基本操作 1 开启事务 start transaction; 2 提交事务 commit; 3 回滚事务 rollback; 注意：一旦使用start transaction;开启事务那么自动提交将失效 如果所有操作都正常执行使用commit;提交事务 当发生异常情况回滚事务，数据(此时为tb_account表)通常回滚到开启事务之前的状态 17.6 转账的操作 -- 1 开启事务 start transaction; -- 2 执行SQL语句 update tb_account set account_blance=account_blance-500 where id=1; 手机转账异常情况：转账过程中手机没电了 update tb_account set account_blance=account_blance+500 where id=2; -- 3 如果SQL语句全部执行成功就提交事务，如果其中任何一步执行失败，立刻回滚事务 -- 此时第一个update执行成功，第二个update语句执行失败了,并没有提交事务，查询结果如下： select * from tb_account; /* +----+-----------+----------------+ | id | user_name | account_blance | +----+-----------+----------------+ | 1 | ZS | 500 | | 2 | LS | 1000 | +----+-----------+----------------+ */ -- 问题：张三账户的余额减少了，李账户余额没有增加。这就是脏数据 -- 此时需要将脏数据回滚到开启事务之前 rollback; -- 回滚完毕再次查询 select * from tb_account; -- 此时事务回滚到开启之前的状态 /* +----+-----------+----------------+ | id | user_name | account_blance | +----+-----------+----------------+ | 1 | ZS | 1000 | | 2 | LS | 1000 | +----+-----------+----------------+ */ -- 一个事务一旦开启了，在没有执行commit或者rollback之前事务不会结束 -- 相关面试题：工作中有没有用到事务？请解释事务的概念？不使用事务会发生什么问题？使用事务能够解决什么问题？解释事务的四大特征[隔离级别]？ 17.7 事务隔离级别 17.7.1 ISO定义的四大隔离级别 事务隔离级别 脏读 不可重复读 幻读 1读未提交（read-uncommitted） 是 是 是 2读已提交（read-committed） 否 是 是 3可重复读（repeatable-read） 否 否 是 4串行化（serializable） 否 否 否 查询隔离级别select @@tx_isolation 隔离级别1最低，4最高 。隔离级别越高就越安全，同时内存资源消耗也越大。隔离级别越高效率越低下。 工作中：1和4都不用，只会在2和3之间切换 MySQL默认的事务隔离级别为3，Oracle默认隔离界别默认为2 17.7.2 并发下的脏读，不可重复读，幻读的问题 问题：不使用事务隔离级别会引发啥问题？使用事务隔离级别能够解决什么问题 17.7.2.1 什么是脏读 一个事务(A)读取到另一个事务(B)没有提交的数据（破坏了隔离性） 例如：事务A开启事务做转账，DML语句执行成功但是没有commit；事务B在另一个窗口开启了，执行Select语句读取tb_account数据，读取到的结果是事务A没有提交的数据。 17.7.2. 不可重复读问题 同一个事务中多次读取到的数据不一致(破坏了一致性，update和delete) 例如：事务A开启事务做转账，DML语句执行成功但是没有commit；；事务B在另一个窗口开启了，执行Select语句读取tb_account数据，读取的结果正确（1000,1000）. 事务A里面提交了事务。然后事务B再次做Select操作查询结果也正确(500,1500) 问题：事务B在一次事务中对tb_account表做了两次select操作，两次操作查询的结果不一致。 17.7.2.3幻读问题 事务A插入一条数据，能够使用select获取结果，此时事务B几乎同时插入了一条或者大量数据，此时事务A看不到事务B的更新（破坏了一致性，insert）。 17.7.3 事务隔离级别的设置查询 set session transaction isolation level READ UNCOMMITTED; #读未提交 set session transaction isolation level READ COMMITTED; #读已提交 set session transaction isolation level REPEATABLE-READ; #可重复读 set session transaction isolation level serializable; #串型化 select @@tx_isolation #查询 17.7.4,read uncommitted脏读测试 设置隔离级别为读未提交 set session transaction isolation level READ UNCOMMITTED; 17.7.5,read committed解决脏读 如何解决脏读问题？修改事务隔离级别：读已提交 set session transaction isolation level read committed; 17.7.6,repeatable read解决不可重复读问题 set session transaction isolation level repeatable read; 数据都改成1000再按下图进行测试 17.7.7 串行化serializable测试 能够解决所有的问题，但是效率低下，它类似Java的synchronized Java使用synchronized用来锁对象。MySQL使用serializable锁表，事务A开启事务，做了DML操作，但是没有提交。此时事务B开启事务，执行select操作，没有查询到数据，因为此时tb_account表被事务A占用了(锁住了)。 set session transaction isolation level serializable; 数据还原 18， 索引 面试的问题： 1，做过SQL调优吗？ 2，为什么索引能加快查询速度，那么是不是索引越多越好 3，除了索引优化，还有没有其它的数据库化方案 18.1，什么是索引 1，大大提高MySQL的查询速度，只能提高查询速度。 2，索引分单列索引和组合索引。单列索引，即一个索引只包含单个列，一个表可以有多个单列索引，但这不是组合索引。组合索引，即一个索引包含多个列。 3，创建索引时，你需要确保该索引是应用在 SQL 查询语句的条件(一般作为 WHERE 子句的条件) 4，建立索引会占用磁盘空间的索引文件 18.2，准备工作创建表 DROP TABLE IF EXISTS person; CREATE TABLE person ( PID int(11) NOT NULL AUTO_INCREMENT COMMENT '编号', PNAME varchar(50) NOT NULL COMMENT '姓名', PSEX varchar(10) NULL DEFAULT NULL COMMENT '性别', PAGE int(11) NOT NULL COMMENT '年龄', SAL decimal(7, 2) NULL DEFAULT NULL COMMENT '工资', PRIMARY KEY (PID) ) ENGINE = InnoDB AUTO_INCREMENT = 1 CHARACTER SET = utf8mb4 COMMENT = '人员表'; 18.3 索引分类 18.3.1 普通索引 【创建语法】 CREATE INDEX &lt;索引名&gt; ON &lt;表名&gt;(字段) 【删除语法】 ALTER TABLE &lt;表名称&gt; DROP INDEX &lt;索引名称&gt; 18.3.1.1 为person表的pname列建立普通索引 CREATE INDEX INDEX_PERSON_PNAME ON PERSON(PNAME) 查询测试 看到了ALL就说明这个查询没有走索引 【创建索引之后再测试】 18.3.1.2 一个表的主键生成之后会默认有一个主键索引 18.3.1.3 where pname like 模糊查询用到索引没有 EXPLAIN SELECT * FROM PERSON WHERE PNAME LIKE 'HELLO' #走索引 EXPLAIN SELECT * FROM PERSON WHERE PNAME LIKE 'HELLO%' #走索引 EXPLAIN SELECT * FROM PERSON WHERE PNAME LIKE '%HELLO%' #不走索引 18.3.2 普通索引的压力测试 向person表中插入500W条数据,为pname创建一个索引，观察创建索引之前执行耗时是多长时间，创建索引之后耗时多长时间。 【删除之前索引】 ALTER TABLE PERSON DROP INDEX INDEX_PERSON_PNAME; 【数据查看】 【创建一个生成随机字符串的函数】 CREATE FUNCTION RAND_STRING(N INT) RETURNS VARCHAR(255) BEGIN DECLARE CHARS_STR VARCHAR(255) DEFAULT 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890'; DECLARE RETURN_STR VARCHAR(255) DEFAULT ''; DECLARE I INT DEFAULT 0; WHILE I&lt;N DO SET RETURN_STR=CONCAT(RETURN_STR,SUBSTRING(CHARS_STR,FLOOR(1+RAND()*62),1)); SET I=I+1; END WHILE; RETURN RETURN_STR; END; 【创建一个存储过程生成数据】 create procedure insert_person(in max_num int(10)) begin declare i int default 0; set autocommit = 0; -- 把autocommit设置成0，这样可以只提交一次，否则。。。。。 repeat set i = i +1; insert into person (PID,PNAME,PSEX,PAGE,SAL) values (i,RAND_STRING(5),IF(RAND()&gt;0.5,'男','女'),FLOOR((RAND()*100)+10),FLOOR((RAND()*19000)+1000)); until i = max_num end repeat; commit; end; 【再次查看数据文件】 【给PNAME创建索引】 CREATE INDEX INDEX_PERSON_PNAME ON PERSON(PNAME) 【查询的说明】 【有索引】 【没有索引】 【四问索引】 问题1：为person表的pname创建索引消耗了9.472秒，为什么耗时这么长？ 在person.ibd数据文件中创建了一个“目录”，目录的结构是一个B+Tree，类似Java的TreeMap，表的数据越多，索引结构越大，创建时间越长。 问题2：没有创建索引执行WHERE PNAME耗时3.892秒，创建索引执行耗时0.03秒，为什么这么快？ 没有创建索引，进行全文检索(从person.ibd数据文件中检索所有的输入，然后在判断是否满足where条件)，创建索引不进行全文检索，直接查询索引 问题3：创建索引之前数据文件person.ibd大小229376，创建索引之后大小319488，为什么会有这么大的变化？ 创建索引就相当于创建目录，表中的数据越大，数据文件就越多。 问题4：INDEX_PERSON_PNAME索引的内部结构是啥？ 类似TreeMap的B+Tree 18.3.2 组合索引的创建 为多个列创建复合索引 CREATE INDEX INDEX_PERSON_AGE_SEX ON PERSON(PAGE,PSEX); CREATE INDEX INDEX_PERSON_AGE_SEX ON PERSON(PAGE,PSEX); EXPLAIN SELECT * FROM PERSON WHERE PAGE=22 AND PSEX='男' #走索引 EXPLAIN SELECT * FROM PERSON WHERE PSEX='男' AND PAGE=22 #走索引 EXPLAIN SELECT * FROM PERSON WHERE PAGE=22 #走索引 EXPLAIN SELECT * FROM PERSON WHERE PSEX='男' #不走索引 总结： 组合索引由多列构成，如果在索引里面的第一列在查询条件里面没有出现就不会走索引 18.3.4 PERSON表的PSEX列只有2个有效值，为该列建立索引会提高查询效率吗 -- 为性别列创建索引【只有两个值 男 女】 SELECT * FROM PERSON WHERE PSEX='男' #2.527s [无索引的时长] CREATE INDEX INDEX_CUSTOMER_SEX ON PERSON(PSEX); EXPLAIN SELECT * FROM PERSON WHERE PSEX='男' #15.307s [索引的时长] 总结：如果数据库字段里面的值的选项少，不能创建索引 18.3.5唯一索引的创建 1，在创建表时指定字段唯 一，那么系统会默认在该字段上加一个唯一索引来提高查询速度 2，CREATE UNIQUE INDEX 索引名称 ON 表名称(列名称);来创建唯一索引 【面试题】 1，做过SQL调优吗？ 绕开这个问题，引入 索引优化，引入数据库的分库分等优化 2，为什么索引能加快查询速度， 索引相当于在数据库里面为我们每一条数据创建一数据库录，查询时不是直接查询数据，而是先找到的目录 3，那么是不是索引越多越好 不是，因为如果是添加和修改和删除会重新调整索引里面的数据【调整过程很耗时】 有索引的情况 会降低添加 删除速度 如果修改的字段上没有索引，那对速度没有影响 4，除了索引优化，还有没有其它的数据库化方案 1，对于常用查询条件创建索引 2，开启SQL的慢查询日志 |--MYSQL会记录所有的查询执行的时间，开启慢查询设置超过2秒的查询就加入慢查询列表，它会把所有超过2秒的查询语做记录，我们程序员过以通过慢查询日志找到具体是哪一个SQL执行的比较，进而针对性的去优化SQL 3，数据量大了怎么办 一般一个表里面的数据超过1000W条数据，就要着手考虑分库分表 |--分库分表的方案 MYSQL 自带了主从结构 和读写分离 [主数据和从数据] |--配合mycat 这种数据库中间件进行分库分表的配置 |--一个表里面的数据量大，那么我们把这个表分成多个表，把数据分开存储 19，数据库设计原则 19.1 数据库设置软件 PowerDesiger 19.2 引入三大范式 目地：保证数据库设计的合理性 用范式来规范我们数据库的设计 19.2.1 第一范式 数据库表每一列都是不可分割的基本数据项，同一列中不能有多个值 简单说就是要确保每列保持原子性 设计表 第一版【编号 姓名 性别 年龄 地址】 ID NAME SEX AGE ADDRESS 1 张三 男 18 湖北省武汉市东湖新技术开发区 第二版【编号 姓名 性别 年龄 省 市 区/镇 街道/村 】 19.2.2 第二范式【多对多】 【要求】 第二范式需要确保数据库表中的每一列都和主键相关，而不能只与主键的某一部分相关（主要针对联合主键而言）。 即在一个数据库表中只能保存一种数据，不可以把多种数据保存在同一张数据库表中。 19.2.3 第三范式【一对多和多对一】 【要求】 确保数据表中的每一列数据都和主键直接相关，而不能间接相关 属性不依赖于其他非主属性。 分析以上的表，发现有问题存在 班级名称和班级信息出现了数据冗余 如何解决 学生表 班级表 1，学生表 2，班级表 19.3 范式的优缺点 19.3.1 优点 结构合理 冗余较小 尽量避免插入删除修改异常 19.3.2 缺点 性能降低 多表查询比单表查询速度慢 19.3.3 数据库的设计应该根据当前情况和需求做出灵活的处理。 在实际设计中，要整体遵循范式理论。 如果在某些特定的情况下还死死遵循范式也是不可取的，因为可能降低数据库的效率，此时可以适当增加冗余而提高性能。 19.3.1 数据库的设计应该根据当前情况和需求做出灵活的处理。 在实际设计中，要整体遵循范式理论。 如果在某些特定的情况下还死死遵循范式也是不可取的，因为可能降低数据库的效率，此时可以适当增加冗余而提高性能。 19.3.2 示例： 比如经常购物车条目的中除了条目编号，商品编号，商品数量外，可以增加经常使用的商品名称，商品价格等 商品表 订单明细表 1. 设计一个商品入库审批的数据库 对象 商品 仓库 入库订单 订单详情 1. 设计一个商品购物车的数据库【作业】 商品表 商家表 用户表 订单表 订单明细]]></summary></entry><entry><title type="html">初识java</title><link href="http://localhost:4000/2022/04/30/%E5%88%9D%E8%AF%86Java.html" rel="alternate" type="text/html" title="初识java" /><published>2022-04-30T00:00:00+08:00</published><updated>2022-04-30T00:00:00+08:00</updated><id>http://localhost:4000/2022/04/30/%E5%88%9D%E8%AF%86Java</id><content type="html" xml:base="http://localhost:4000/2022/04/30/%E5%88%9D%E8%AF%86Java.html"><![CDATA[<h1 id="计算机语言发展史">计算机语言发展史</h1>

<p>第一代：机器语言</p>

<p>采用0和1进行编码，还需要掌握硬件知识</p>

<p>第二代：汇编语言</p>

<p>采用英文单词进行编码，还需要掌握硬件知识</p>

<p>第三代：高级语言</p>

<p>采用英文单词进行编码， 不需要掌握硬件知识</p>

<ul>
  <li>
    <p>面向过程</p>

    <ul>
      <li>C语言</li>
    </ul>

    <p>特点：强调线性思维，先做什么，再做什么。适合做小型应用，比如计算器、红绿灯、门禁。整体性能较高。</p>
  </li>
  <li>
    <p>面向对象</p>

    <ul>
      <li>Java</li>
      <li>C++</li>
      <li>C#</li>
    </ul>

    <p>特点：强调宏观控制，微观下依然是面向过程，适合做大型应用，比如购物网站、抢票软件等</p>
  </li>
</ul>

<h1 id="java语言发展史">Java语言发展史</h1>

<p>SUN公司的詹姆斯高斯林想要开发一款编程语言，用于机顶盒一类消费类电子产品中。</p>

<p>机顶盒有很多厂商，这些厂商采用的硬件、系统都有可能不同，因此在A厂商机顶盒中开发的软件，可能无法适配其他厂商。因此詹姆斯高斯林想要开发一款软件，不关注系统和硬件具体是什么，都能够正常运行，也就是说想要这门语言能够<strong>跨平台</strong></p>

<p>开发：用轮子</p>

<p>研发：研究出轮子</p>

<p>Java版本目前已经迭代到17，但是在开发中使用最多的依然是JDK8，其次是JDK7和JDK11。</p>

<h2 id="java版本含义">Java版本含义</h2>

<p>JavaSE：用于开发个人电脑的应用 C#</p>

<p>JavaEE：用于开发企业级应用（WEB后端、大数据）</p>

<p>JavaME：用于移动设备或者嵌入式设备中 C/C++</p>

<h1 id="java的特点">Java的特点</h1>

<ol>
  <li>
    <p>跨平台</p>

    <p>Java运行在JVM虚拟机中，通过在不同系统中安装适配的Java虚拟机，虚拟机就可以运行Java程序。一处编译，到处运行。</p>
  </li>
  <li>
    <p>简单</p>

    <p>Java摒弃了面向过程语言中较为复杂的内容，比如预处理、指针、结构体、手动内存管理、多重继承</p>

    <p>不再有函数（一般规定在类中的功能代码块称之为“方法”，而不在类中的称之为“函数”）</p>

    <p>不再有全局变量、枚举。在Java中可以通过类去模拟出全局变量和枚举</p>
  </li>
  <li>
    <p>安全</p>

    <p>Java摒弃了指针，摒弃了手动的内存管理，不允许用户直接操作内存</p>
  </li>
  <li>
    <p>完全面向对象</p>

    <p>C++是半面向对象半面向过程，为了兼容C语言保留了大量的面向过程的内容，因此显得语言冗余。而Java则完全抛弃了面向过程的内容，是纯面向对象的。</p>
  </li>
  <li>
    <p>健壮</p>

    <p>不容易出问题，因为Java摒弃了面向过程中很容易出现bug的技术点，开发者无法直接操作硬件设备，间接地提高了程序的健壮性</p>
  </li>
</ol>

<h1 id="java跨平台原理">Java跨平台原理</h1>

<p>Java跨平台取决于JVM虚拟机。JVM虚拟机就是跨平台的关键。</p>

<p>编程语言的分类：编译型、解释型</p>

<p>编译型：先将程序进行编译，编译完毕后再进行运行</p>

<p>解释型：直接运行，一遍解释一遍运行。</p>

<p>Java是既有编译型也有解释型</p>

<p><img src="assets\1633849054195.png" alt="1633849054195" /></p>

<h1 id="常见dos命令">常见DOS命令</h1>

<ol>
  <li>
    <p>盘符操作</p>

    <p>切换盘符</p>

    <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>盘符:
</code></pre></div>    </div>
  </li>
  <li>
    <p>目录操作</p>

    <p>切换目录</p>

    <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cd </span>目录名
</code></pre></div>    </div>

    <p>回到上一级</p>

    <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cd</span> ..
</code></pre></div>    </div>

    <p>返回根目录</p>

    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">cd</span> <span class="o">/</span>
</code></pre></div>    </div>

    <p>显示目录下文件</p>

    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">dir</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>文件夹操作</p>

    <p>创建文件夹</p>

    <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>md 文件夹名称
</code></pre></div>    </div>

    <p>删除文件夹</p>

    <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rd 文件夹名称
</code></pre></div>    </div>
  </li>
  <li>
    <p>文件操作</p>

    <p>拷贝文件</p>

    <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>copy 源文件 目标文件
</code></pre></div>    </div>

    <p>删除文件</p>

    <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>del 文件名
</code></pre></div>    </div>
  </li>
  <li>
    <p>辅助命令</p>

    <p>退出窗口</p>

    <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">exit</span>
</code></pre></div>    </div>

    <p>清空窗口</p>

    <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cls
</code></pre></div>    </div>

    <p>自动补全</p>

    <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>tab键
</code></pre></div>    </div>

    <p>显示之前或之后已执行的命令</p>

    <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>上下箭头
</code></pre></div>    </div>

    <p>帮助命令</p>

    <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">help</span>
</code></pre></div>    </div>
  </li>
</ol>

<h1 id="第一个java程序">第一个Java程序</h1>

<h2 id="编写代码">编写代码</h2>

<p>在代码的目录下创建文件 <code class="language-plaintext highlighter-rouge">HelloWorld.java</code>，文件名保持一致，右击编辑</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">HelloWorld</span> <span class="o">{</span>
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
		<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"HelloWorld"</span><span class="o">);</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">public class</code> 是声明这是一个公共的 <strong>类</strong>，HelloWorld就是 <strong>类名</strong>，类名需要与Java文件名保持一致</li>
  <li><code class="language-plaintext highlighter-rouge">public static void main(String[] args)</code> 是固定写法，Java程序的入口就是main</li>
  <li><code class="language-plaintext highlighter-rouge">System.out.println("HelloWorld");</code> 作用是输出一行文本，文本内容是 HelloWorld</li>
</ul>

<h2 id="编译代码">编译代码</h2>

<p>程序编写完毕后无法直接运行，需要进行  <strong>编译</strong></p>

<p>编译使用 <code class="language-plaintext highlighter-rouge">javac 文件名</code> 进行操作，文件名需要加上后缀</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>javac HelloWorld.java
</code></pre></div></div>

<h2 id="运行程序">运行程序</h2>

<p>程序编译完毕后需要执行程序，执行程序使用 <code class="language-plaintext highlighter-rouge">java 类名</code> 。类名不需要加上 .java后缀</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>java HelloWorld
</code></pre></div></div>

<h2 id="语法规范">语法规范</h2>

<ol>
  <li>类名遵循 <strong>驼峰规则</strong>（单词与单词之间首字母大写）</li>
  <li>在一个Java程序中最多只能有一个 <code class="language-plaintext highlighter-rouge">public class</code>，并且这个类的类名需要与Java文件名完全一致</li>
  <li>类名可以由字母、数字、下划线、美元符号组成，并且第一个字符不能是数字。一般只使用字母和数字</li>
  <li>在类和方法中，代码都是写到大括号内的 <code class="language-plaintext highlighter-rouge">{}</code>，并且大括号要成对</li>
  <li>合理使用缩进，使代码更加有结构性</li>
  <li>Java程序每一行代码以英文分号 <code class="language-plaintext highlighter-rouge">;</code> 结尾</li>
  <li><strong>成对编程</strong>，代码中的括号、引号等都需要成对编写。</li>
  <li>Java中是对大小写敏感的，单词的大小写不能出错</li>
</ol>

<h1 id="常见问题">常见问题</h1>

<h2 id="缺少空格">缺少空格</h2>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">publicclass</span> <span class="nc">HelloWorld</span> <span class="o">{</span>
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
		<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"HelloWorld"</span><span class="o">);</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="大小写错误">大小写错误</h2>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">HelloWorld</span> <span class="o">{</span>
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">string</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
		<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"HelloWorld"</span><span class="o">);</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="main方法名称写错">main方法名称写错</h2>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">HelloWorld</span> <span class="o">{</span>
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">mian</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
		<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"HelloWorld"</span><span class="o">);</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="没有成对编程">没有成对编程</h2>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">HelloWorld</span> <span class="o">{</span>
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
		<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"HelloWorld"</span><span class="o">);</span>
	


<span class="o">}</span>
</code></pre></div></div>

<h2 id="缺少分号">缺少分号</h2>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">HelloWorld</span> <span class="o">{</span>
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
		<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"HelloWorld"</span><span class="o">)</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="使用了中文字符">使用了中文字符</h2>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">HelloWorld</span> <span class="o">{</span>
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
		<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="err">“</span><span class="nc">HelloWorld</span><span class="err">”</span><span class="o">)</span>
	<span class="o">}</span>


<span class="o">}</span>
</code></pre></div></div>

<blockquote>
  <p>注意：命令窗口默认的GBK编码，而记事本使用的是UTF-8编码。编码不一致就会导致运行时对于中文字符的处理会出现乱码</p>
</blockquote>

<h1 id="代码的注释">代码的注释</h1>

<p>在我们编写代码的过程中，需要去对某些代码进行描述、备注。此时可以使用 <strong>注释</strong></p>

<p>注释在编译后不会被编译到字节码文件中</p>

<p>代码是给机器看的，注释是给人看的</p>

<h2 id="单行注释">单行注释</h2>

<p>单行注释使用两个斜杠 <code class="language-plaintext highlighter-rouge">//</code> 进行表示，以这一行作为结尾</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 我是注释</span>
</code></pre></div></div>

<h2 id="多行注释">多行注释</h2>

<p>多行注释使用 <code class="language-plaintext highlighter-rouge">/*</code> 开头，使用 <code class="language-plaintext highlighter-rouge">*/</code> 结尾，可以用来注释多行内容，从 <code class="language-plaintext highlighter-rouge">/*</code>到 <code class="language-plaintext highlighter-rouge">*/</code> 范围内所有的内容全部都是注释。<strong>多行注释不能嵌套</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
我是多行注释
哈哈哈哈
我是第三行注释内容
*/</span>
</code></pre></div></div>

<h2 id="文档注释">文档注释</h2>

<p>文档注释与多行注释非常相似，以 <code class="language-plaintext highlighter-rouge">/**</code> 开头，以 <code class="language-plaintext highlighter-rouge">*/</code> 结尾。在文档注释中可以标注某个方法的参数、返回值、异常等信息。文档注释可以通过 JavaDOC去生成出API文档</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
我是文档注释，可以用来更加详细的描述方法内容
也可以使用JAVADOC生成API文档
*/</span>
</code></pre></div></div>

<p>以后的开发中要养成随手写注释的习惯</p>]]></content><author><name>qihuan</name></author><summary type="html"><![CDATA[计算机语言发展史 第一代：机器语言 采用0和1进行编码，还需要掌握硬件知识 第二代：汇编语言 采用英文单词进行编码，还需要掌握硬件知识 第三代：高级语言 采用英文单词进行编码， 不需要掌握硬件知识 面向过程 C语言 特点：强调线性思维，先做什么，再做什么。适合做小型应用，比如计算器、红绿灯、门禁。整体性能较高。 面向对象 Java C++ C# 特点：强调宏观控制，微观下依然是面向过程，适合做大型应用，比如购物网站、抢票软件等 Java语言发展史 SUN公司的詹姆斯高斯林想要开发一款编程语言，用于机顶盒一类消费类电子产品中。 机顶盒有很多厂商，这些厂商采用的硬件、系统都有可能不同，因此在A厂商机顶盒中开发的软件，可能无法适配其他厂商。因此詹姆斯高斯林想要开发一款软件，不关注系统和硬件具体是什么，都能够正常运行，也就是说想要这门语言能够跨平台 开发：用轮子 研发：研究出轮子 Java版本目前已经迭代到17，但是在开发中使用最多的依然是JDK8，其次是JDK7和JDK11。 Java版本含义 JavaSE：用于开发个人电脑的应用 C# JavaEE：用于开发企业级应用（WEB后端、大数据） JavaME：用于移动设备或者嵌入式设备中 C/C++ Java的特点 跨平台 Java运行在JVM虚拟机中，通过在不同系统中安装适配的Java虚拟机，虚拟机就可以运行Java程序。一处编译，到处运行。 简单 Java摒弃了面向过程语言中较为复杂的内容，比如预处理、指针、结构体、手动内存管理、多重继承 不再有函数（一般规定在类中的功能代码块称之为“方法”，而不在类中的称之为“函数”） 不再有全局变量、枚举。在Java中可以通过类去模拟出全局变量和枚举 安全 Java摒弃了指针，摒弃了手动的内存管理，不允许用户直接操作内存 完全面向对象 C++是半面向对象半面向过程，为了兼容C语言保留了大量的面向过程的内容，因此显得语言冗余。而Java则完全抛弃了面向过程的内容，是纯面向对象的。 健壮 不容易出问题，因为Java摒弃了面向过程中很容易出现bug的技术点，开发者无法直接操作硬件设备，间接地提高了程序的健壮性 Java跨平台原理 Java跨平台取决于JVM虚拟机。JVM虚拟机就是跨平台的关键。 编程语言的分类：编译型、解释型 编译型：先将程序进行编译，编译完毕后再进行运行 解释型：直接运行，一遍解释一遍运行。 Java是既有编译型也有解释型 常见DOS命令 盘符操作 切换盘符 盘符: 目录操作 切换目录 cd 目录名 回到上一级 cd .. 返回根目录 cd / 显示目录下文件 dir 文件夹操作 创建文件夹 md 文件夹名称 删除文件夹 rd 文件夹名称 文件操作 拷贝文件 copy 源文件 目标文件 删除文件 del 文件名 辅助命令 退出窗口 exit 清空窗口 cls 自动补全 tab键 显示之前或之后已执行的命令 上下箭头 帮助命令 help 第一个Java程序 编写代码 在代码的目录下创建文件 HelloWorld.java，文件名保持一致，右击编辑 public class HelloWorld { public static void main(String[] args) { System.out.println("HelloWorld"); } } public class 是声明这是一个公共的 类，HelloWorld就是 类名，类名需要与Java文件名保持一致 public static void main(String[] args) 是固定写法，Java程序的入口就是main System.out.println("HelloWorld"); 作用是输出一行文本，文本内容是 HelloWorld 编译代码 程序编写完毕后无法直接运行，需要进行 编译 编译使用 javac 文件名 进行操作，文件名需要加上后缀 javac HelloWorld.java 运行程序 程序编译完毕后需要执行程序，执行程序使用 java 类名 。类名不需要加上 .java后缀 java HelloWorld 语法规范 类名遵循 驼峰规则（单词与单词之间首字母大写） 在一个Java程序中最多只能有一个 public class，并且这个类的类名需要与Java文件名完全一致 类名可以由字母、数字、下划线、美元符号组成，并且第一个字符不能是数字。一般只使用字母和数字 在类和方法中，代码都是写到大括号内的 {}，并且大括号要成对 合理使用缩进，使代码更加有结构性 Java程序每一行代码以英文分号 ; 结尾 成对编程，代码中的括号、引号等都需要成对编写。 Java中是对大小写敏感的，单词的大小写不能出错 常见问题 缺少空格 publicclass HelloWorld { public static void main(String[] args) { System.out.println("HelloWorld"); } } 大小写错误 public class HelloWorld { public static void main(string[] args) { System.out.println("HelloWorld"); } } main方法名称写错 public class HelloWorld { public static void mian(String[] args) { System.out.println("HelloWorld"); } } 没有成对编程 public class HelloWorld { public static void main(String[] args) { System.out.println("HelloWorld"); } 缺少分号 public class HelloWorld { public static void main(String[] args) { System.out.println("HelloWorld") } } 使用了中文字符 public class HelloWorld { public static void main(String[] args) { System.out.println(“HelloWorld”) } } 注意：命令窗口默认的GBK编码，而记事本使用的是UTF-8编码。编码不一致就会导致运行时对于中文字符的处理会出现乱码 代码的注释 在我们编写代码的过程中，需要去对某些代码进行描述、备注。此时可以使用 注释 注释在编译后不会被编译到字节码文件中 代码是给机器看的，注释是给人看的 单行注释 单行注释使用两个斜杠 // 进行表示，以这一行作为结尾 // 我是注释 多行注释 多行注释使用 /* 开头，使用 */ 结尾，可以用来注释多行内容，从 /*到 */ 范围内所有的内容全部都是注释。多行注释不能嵌套 /* 我是多行注释 哈哈哈哈 我是第三行注释内容 */ 文档注释 文档注释与多行注释非常相似，以 /** 开头，以 */ 结尾。在文档注释中可以标注某个方法的参数、返回值、异常等信息。文档注释可以通过 JavaDOC去生成出API文档 /** 我是文档注释，可以用来更加详细的描述方法内容 也可以使用JAVADOC生成API文档 */ 以后的开发中要养成随手写注释的习惯]]></summary></entry><entry><title type="html">Welcome</title><link href="http://localhost:4000/2018/07/01/welcome.html" rel="alternate" type="text/html" title="Welcome" /><published>2018-07-01T00:00:00+08:00</published><updated>2018-07-01T00:00:00+08:00</updated><id>http://localhost:4000/2018/07/01/welcome</id><content type="html" xml:base="http://localhost:4000/2018/07/01/welcome.html"><![CDATA[<p>If you see this page, that means you have setup your site. enjoy! :ghost: :ghost: :ghost:</p>

<p>You may want to <a href="https://tianqi.name/jekyll-TeXt-theme/docs/en/configuration">config the site</a> or <a href="https://tianqi.name/jekyll-TeXt-theme/docs/en/writing-posts">writing a post</a> next. Please feel free to <a href="https://github.com/kitian616/jekyll-TeXt-theme/issues">create an issue</a> or <a href="mailto:kitian616@outlook.com">send me email</a> if you have any questions.</p>

<!--more-->

<hr />

<p>If you like TeXt, don’t forget to give me a star. :star2:</p>

<p><a href="https://github.com/kitian616/jekyll-TeXt-theme/"><img src="https://img.shields.io/github/stars/kitian616/jekyll-TeXt-theme.svg?label=Stars&amp;style=social" alt="Star This Project" /></a></p>]]></content><author><name>qihuan</name></author><category term="TeXt" /><summary type="html"><![CDATA[If you see this page, that means you have setup your site. enjoy! :ghost: :ghost: :ghost: You may want to config the site or writing a post next. Please feel free to create an issue or send me email if you have any questions.]]></summary></entry><entry><title type="html">Post with Header Image</title><link href="http://localhost:4000/2018/06/01/header-image.html" rel="alternate" type="text/html" title="Post with Header Image" /><published>2018-06-01T00:00:00+08:00</published><updated>2018-06-01T00:00:00+08:00</updated><id>http://localhost:4000/2018/06/01/header-image</id><content type="html" xml:base="http://localhost:4000/2018/06/01/header-image.html"><![CDATA[<p>A Post with Header Image, See <a href="https://tianqi.name/jekyll-TeXt-theme/samples.html#page-layout">Page layout</a> for more examples.</p>

<!--more-->]]></content><author><name>qihuan</name></author><category term="TeXt" /><summary type="html"><![CDATA[A Post with Header Image, See Page layout for more examples.]]></summary></entry></feed>